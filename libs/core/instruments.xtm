;;; instruments.xtm -- instruments (core)

;; Author: Andrew Sorensen
;; Keywords: extempore

;;; Commentary:

;; This is for instruments which are solely written in scheme and
;; xtlang - no binding to external (that is, C) libraries.
;;
;; Any instruments which depend on external libraries are
;; in libs/external/instruments_ext.xtm

;;; Code:

;; lib-loading config
(sys:load "libs/aot-cache/instruments.xtm" 'quiet)
(sys:load-preload-check 'instruments)

(define *xtmlib-instruments-loaded* #f)

(impc:aot:suppress-aot-do
 (sys:load "libs/core/audio_dsp.xtm"))
(impc:aot:insert-forms (sys:load "libs/core/audio_dsp.xtm" 'quiet))

(impc:aot:insert-header "xtminstruments")


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; making a polyphonic instrument
;;

(bind-val MAXPOLYPHONY i64 40)

;; Structure for init values of each note
;; idx(0) start(1) freq(2) amp(3) dur(4) gate(5) active(6) refcnt(7) zone(8)
(bind-type NoteData <i64,i64,SAMPLE,SAMPLE,i64,SAMPLE,i1,i64,i8*>)

(bind-func note_idx (lambda (data:NoteData*) (tref data 0)))
(bind-func note_starttime (lambda (data:NoteData*) (tref data 1)))
(bind-func note_frequency (lambda (data:NoteData*) (tref data 2)))
(bind-func note_amplitude (lambda (data:NoteData*) (tref data 3)))
(bind-func note_duration (lambda (data:NoteData*) (tref data 4)))
(bind-func note_gate (lambda (data:NoteData*) (tref data 5)))
(bind-func note_gate (lambda (data:NoteData* value) (tset! data 5 value)))
(bind-func note_active (lambda (data:NoteData*) (tref data 6)))
(bind-func note_active (lambda (data:NoteData* value) (tset! data 6 value)))
(bind-func note_refcnt (lambda (data:NoteData*) (tref data 7)))
(bind-func note_ref_inc (lambda (data:NoteData*) (tset! data 7 (+ 1 (tref data 7)))))
(bind-func note_ref_dec (lambda (data:NoteData*) (let ((v (- (tref data 7) 1)))
                                              (if (< v 0)
                                                  (tset! data 7 0)
                                                  (tset! data 7 v)))))
(bind-func note_zone (lambda (data:NoteData*) (cast (tref data 8) mzone*)))

(bind-alias INSTRUMENT [SAMPLE,SAMPLE,i64,i64,SAMPLE*]*)
(bind-alias NOTE_KERNEL [[SAMPLE,i64,i64]*,NoteData*,i64,SAMPLE*]*)
(bind-alias FX_KERNEL [SAMPLE,SAMPLE,i64,i64,SAMPLE*]*)


(bind-func instrument_find_note
  (lambda (notes:NoteData** lgth)
    (let ((idx 0)
          (i 0)
          (old (note_starttime (pref notes 0)))
          (active #f)
          (starttime 0)
          (go #t))
      (while (= #t go)
        (set! starttime (note_starttime (pref notes i)))
        ;; this refcnt reset is a temporary bugfix - there is a more fundemental problem with refcnt in make_instrument
        (if (and (not (note_active (pref notes i)))
                 (> (note_refcnt (pref notes i)) 0))
            (tset! (pref notes i) 7 0))
        (if (and (< starttime old) (< (note_refcnt (pref notes i)) 1))
            (begin (set! old starttime) (set! idx i)))
        (set! active (note_active (pref notes i)))
        (if (and (not active) (< (note_refcnt (pref notes i)) 1)) 
            (begin (set! idx i) (set! go #f)))
        ;; (println '-- i (note_active (pref notes i)) (note_refcnt (pref notes i)))
        (set! i (+ i 1))
        (if (= i lgth) (set! go #f))
        void)
      ;; (println "note:" idx (note_active (pref notes idx)) (note_refcnt (pref notes idx)))
      (pref notes idx))))


(bind-func make_instrument
  (lambda (note_kernel:NOTE_KERNEL effect_kernel:FX_KERNEL)
    (effect_kernel.notekernel:NOTE_KERNEL note_kernel)
    (let* ((maxpoly:i64 MAXPOLYPHONY)
           (tmp_active:i64 0)
           (numactive:i64 0)           
           (poly:i64 maxpoly)
           (notes:NoteData** (zalloc poly))
           (note_event_buf:i64 10)
           (note_events:<i64,SAMPLE,SAMPLE,i64,NoteData*>* (alloc note_event_buf))
           (note_event:<i64,SAMPLE,SAMPLE,i64,NoteData*>* null)
           (note_event_b:<i64,SAMPLE,SAMPLE,i64,NoteData*>* null)           
           (note_event_c:<i64,SAMPLE,SAMPLE,i64,NoteData*>* null)           
           (note_event_in_idx:i64 0)
           (note_event_out_idx:i64 0)
           (note_event_out_idx_b:i64 0)
           (note_event_out_idx_c:i64 0)
           (note_event_out_time:i64 #x0FFFFFFFFFFFFFFF)
           (note_event_out_time_b:i64 #x0FFFFFFFFFFFFFFF)           
           (note_event_out_time_c:i64 #x0FFFFFFFFFFFFFFF)           
           (note_event_note:NoteData* null)
           (note:NoteData* null)           
           (kernels:[SAMPLE,i64,i64]** (zalloc poly))
           (kernel:[SAMPLE,i64,i64]* null)
           (nullkernel:[SAMPLE,i64,i64]* null)           
           (starttime:i64 0)
           (out:SAMPLE 0.0)
           (zzone:mzone* null)
           (k:i64 0) (i:i64 0) (j:i64 0)
           (new_note (lambda (start:i64 freq:SAMPLE dur:i64 amp:SAMPLE nargs:i64 dargs:SAMPLE*)
                       (let ((free_note (instrument_find_note notes poly))
                             (idx (note_idx free_note))
                             (zone (note_zone free_note)))
                         (if (null? free_note)
                             null
                             (if (or (note_active free_note)
                                     (> (note_refcnt free_note) 0))
                                 (begin ;; resuse existing kernel
                                   (set! note_event_b (pref-ptr note_events note_event_in_idx))
                                   (tfill! note_event_b start freq amp dur free_note)
                                   (note_ref_inc free_note) ;; increment note refcnt
                                   ;; (println "A idx:" (note_idx free_note) start freq amp dur)
                                   (set! note_event_out_time_b #x0FFFFFFFFFFFFFFF)
                                   (dotimes (j note_event_buf)
                                     (set! note_event_b (pref-ptr note_events j))
                                     (if (< (tref note_event_b 0) note_event_out_time_b)
                                         (begin (set! note_event_out_time_b (tref note_event_b 0))
                                                (set! note_event_out_idx_b j))))
                                   (set! note_event_out_time note_event_out_time_b)
                                   (set! note_event_out_idx note_event_out_idx_b)
                                   ;; (println "Next new event is:" note_event_out_time note_event_out_idx)
                                   (set! note_event_in_idx (% (+ 1 note_event_in_idx) note_event_buf))
                                   (tset! free_note 1 start)
                                   ;; existing kernel is still in use!
                                   free_note)
                                 (begin ;; create new kernel
                                   ;; (println "B idx:" (note_idx free_note) start freq amp dur)
                                   (reset_zone zone)
                                   (push_zone zone)
                                   ;; refcnt should already be 0!! (otherwise we shouldn't get here!)
                                   (if (> (note_refcnt free_note) 0)
                                       (println "ERROR: note with refcnt > 0 should'nt get here!"))
                                   ;; initialize kernel with active set to #f
                                   (tfill! free_note idx start freq amp dur 1.0 #f 0 (cast zone i8*))
                                   ;; init new kernel
                                   (pset! kernels idx (note_kernel free_note nargs dargs))
                                   ;; activate to true once kernel is valid
                                   (note_active free_note #t) ;; don't activate until kernel is valid!
                                   (pop_zone)
                                   free_note)))))))
      ;; init note events
      (dotimes (i 10)
        (tfill! (pref-ptr note_events i) #x0FFFFFFFFFFFFFFF 0.0 0.0 0 null))      
      ;; init notes
      (dotimes (i poly)
        (pset! kernels i (cast null))
        (pset! notes i (NoteData i 0 0.0 0.0 0 1.0 #f 0 (cast (create_zone (* 10 1024))))))
      ;; sum all active note kernels and then process through effect kernel
      (lambda (in:SAMPLE time:i64 chan:i64 dat:SAMPLE*)
        (set! out 0.0)
        (set! tmp_active 0)
        (if (> time note_event_out_time)
            (begin
              ;; (println "HIT with new event:" note_event_out_time note_event_out_idx)
              (set! note_event_c (pref-ptr note_events note_event_out_idx))
              (set! note_event_note (tref note_event_c 4)) ;(instrument_find_note notes poly))
              (if (not (null? note_event_note))
                  (begin
                    (tset! note_event_note 1 (tref note_event_c 0))
                    (tset! note_event_note 2 (tref note_event_c 1))
                    (tset! note_event_note 3 (tref note_event_c 2))
                    (tset! note_event_note 4 (tref note_event_c 3))
                    (tset! note_event_note 5 1.0)
                    (tset! note_event_note 6 #t)
                    (note_ref_dec note_event_note)
                    ;; (println "C:" note_event_note)
                    void))
              (tset! note_event_c 0 #x0FFFFFFFFFFFFFFF)
              (tset! note_event_c 4 null)
              (set! note_event_out_time_c #x0FFFFFFFFFFFFFFF)
              (dotimes (k note_event_buf)
                (set! note_event_c (pref-ptr note_events k))
                (if (< (tref note_event_c 0) note_event_out_time_c)
                    (begin (set! note_event_out_time_c (tref note_event_c 0))
                           (set! note_event_out_idx_c k))))
              (set! note_event_out_time note_event_out_time_c)
              (set! note_event_out_idx note_event_out_idx_c)
              ;; (println "Next new event will be:" note_event_out_time note_event_out_idx)
              void))
        (dotimes (k poly) ;; sum all active notes
          (set! note (pref notes k))
          (set! starttime (tref note 1)) ;; tref (faster)
          (if (not (tref note 6)) ;; if not active
              (begin void) ;(tset! note 1 #x0FFFFFFFFFFFFFFF) void) ;; (pset! kernels k nullkernel) void)
              (begin (set! tmp_active (+ tmp_active 1)) void))
          (set! kernel (pref kernels k))
          (if (and (> time starttime) (tref note 6)) ; (not (null? kernel)))
              (set! out (+ out (* 0.2 (kernel time chan))))))
        (set! numactive tmp_active)
        (effect_kernel out time chan dat)))))

                       

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; making and playing notes

(bind-func xtm_play_note
  (lambda (time inst:INSTRUMENT freq amp dur nargs:i64 dargs)
    (if (> freq 10.0)
        (let ((f (inst.new_note:[NoteData*,i64,SAMPLE,i64,SAMPLE,i64,SAMPLE*]*))
              (note:NoteData* (f time freq dur amp nargs dargs)))
          note)
        null)))

(bind-func xtm_start_note
  (lambda (time inst:INSTRUMENT freq amp nargs:i64 dargs)
    (if (> freq 10.0)
        (let ((dur 1000000000000)
              (f (inst.new_note:[NoteData*,i64,SAMPLE,i64,SAMPLE,i64,SAMPLE*]*))
              (note:NoteData* (f time freq dur amp nargs dargs)))
          note)
        null)))

(bind-func xtm_stop_note
  (lambda (note:i8*)
    (let ((nd:NoteData* (cast note)))
      (if (not (null? nd))
          (note_active nd #f)))
    void))

(bind-func xtm_release_note
  (lambda (note:i8*)
    (let ((nd:NoteData* (cast note)))
      (if (not (null? nd))
          (note_gate nd 0.0)))
    void))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; play for use with native beat shceduler
;;

(bind-func xtm_play
  (lambda (offset:double bsched:[void]* inst:[SAMPLE,SAMPLE,i64,i64,SAMPLE*]*
                    pitch:double vol:double dur:double
                    num:i64 mem:SAMPLE*)
    (let ((bpm (bsched.bpm)))
      (xtm_play_note (+ (now) (dtoi64 (* offset (/ 60.0 bpm) SRd)))
                     inst
                     (midi2frq (convert pitch))
                     (convert (/ (exp (/ vol 26.222)) 127.0))
                     (dtoi64 (* dur (/ 60.0 bpm) SRd))
                     num mem))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; GLOBAL INSTRUMENT STUFF
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; global params for all instruments

(bind-val PARAM_SINE enum 0)
(bind-val PARAM_SAW enum 1)
(bind-val PARAM_PULSE enum 2)
(bind-val PARAM_TRI enum 3)
(bind-val PARAM_AD enum 4)
(bind-val PARAM_CONST enum 5)
(bind-val PARAM_WHITE enum 0)
(bind-val PARAM_PINK enum 1)

;; filter types
(bind-val PARAM_LPF enum 0)
(bind-val PARAM_BPF enum 1)
(bind-val PARAM_HPF enum 2)
(bind-val PARAM_Notch enum 3)
(bind-val PARAM_Peak enum 4)
(bind-val PARAM_APF enum 5)

;; modulation sources
(bind-val PARAM_LFO1 enum 0)
(bind-val PARAM_LFO2 enum 1)
(bind-val PARAM_LFO3 enum 2)
(bind-val PARAM_LFO4 enum 3)

;; modulation destinations (note)
(bind-val PARAM_OSC1_AMP enum 0)
(bind-val PARAM_OSC1_FRQ enum 1)
(bind-val PARAM_OSC1_PW enum 2)
(bind-val PARAM_OSC1_PAN enum 3)
(bind-val PARAM_OSC2_AMP enum 4)
(bind-val PARAM_OSC2_FRQ enum 5)
(bind-val PARAM_OSC2_PW enum 6)
(bind-val PARAM_OSC2_PAN enum 7)
(bind-val PARAM_OSC3_AMP enum 8)
(bind-val PARAM_OSC3_FRQ enum 9)
(bind-val PARAM_OSC3_PW enum 10)
(bind-val PARAM_OSC3_PAN enum 11)
(bind-val PARAM_OSC4_AMP enum 12)
(bind-val PARAM_OSC4_FRQ enum 13)
(bind-val PARAM_OSC4_PW enum 14)
(bind-val PARAM_OSC4_PAN enum 15)
(bind-val PARAM_NOISE_AMP enum 16)
(bind-val PARAM_FILTER_FRQ enum 17)
(bind-val PARAM_FILTER_RES enum 18)

;; modulation destinations (fx)
(bind-val PARAM_PAN_WIDTH enum 19)
(bind-val PARAM_PAN_POS enum 20) 
(bind-val PARAM_DELAY_TIME_LEFT enum 21)
(bind-val PARAM_DELAY_TIME_RIGHT enum 22)
(bind-val PARAM_DELAY_FB enum 23) ;; feedback
(bind-val PARAM_REVERB_SIZE enum 24)
(bind-val PARAM_REVERB_PREDELAY enum 25)
(bind-val PARAM_REVERB_ABSORB enum 26)
(bind-val PARAM_REVERB_MIX enum 27)
(bind-val PARAM_FLANGER_LOW enum 28)
(bind-val PARAM_FLANGER_HIGH enum 29)
(bind-val PARAM_FLANGER_RATE enum 30)
(bind-val PARAM_FLANGER_FB enum 31)



;;
;; stops all active notes on instrument
;;
(bind-func stop_running
  (lambda (inst:i8*)
    (let ((notes (cref (cast inst [void]*) notes NoteData**))
          (i 0))
      (dotimes (i MAXPOLYPHONY)
        (pset! notes i (NoteData i 0 0.0 0.0 0 1.0 #f 0 (cast (create_zone (* 10 1024))))))
      void)))

;;
;; sets the number of voices for this instrument
;;
(bind-func set_polyphony
  (lambda (inst:i8* val:i64)
    (stop_running inst) ;; force a stop on all notes before changing poly count
    (if (and (> val 0) (< val (+ 1 MAXPOLYPHONY)))
        (begin (cset! (cast inst [void]*) poly val i64)
               void)
        (begin (println "Invalid argument, must be greater than 0 and less than MAXPOLYPHONY")
               void))
    void))

(bind-func set_monophonic
  (lambda (inst:i8*)
    (stop_running inst)  ;; force a stop on all notes before changing poly count
    (cset! (cast inst [void]*) poly 1 i64)
    void))

(bind-func set_polyphonic
  (lambda (inst:i8*)
    (stop_running inst)  ;; force a stop on all notes before changing poly count
    (cset! (cast inst [void]*) poly MAXPOLYPHONY i64)
    void))


(bind-func active_notes
  (lambda (inst:i8*)
    (let ((val (cref (cast inst [void]*) numactive i64)))
      (println "Instrument has" val "active notes")
      void)))

;;
;; note kernel params for ALL instruments
;;

;; time in milliseconds to glide between note frequencies
(bind-func set_portamento
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note portamento val float)
      void)))

(bind-func get_portamento
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note portamento float))))

;; only effects monophonic (i.e. 1 note polyphony)
;; if legato is #t then don't retrigger adsr's
(bind-func set_legato
  (lambda (inst:i8* val:i32)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note legato (if (= val 0) #f #t) i1)
      void)))

(bind-func get_legato
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note legato i1))))

(bind-func set_osc1_pan
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note osc1_pan val float)
      void)))

(bind-func get_osc1_pan
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note osc1_pan float))))

(bind-func set_osc1_amp
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note osc1_amp val float)
      void)))

(bind-func get_osc1_amp
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note osc1_amp float))))

(bind-func set_osc1_tune
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note tune1 val float)
      void)))

(bind-func get_osc1_tune
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note tune1 float))))

(bind-func set_osc1_pw
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note pw1 val float)
      void)))

(bind-func get_osc1_pw
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note pw1 float))))

(bind-func set_osc1_wave
  (lambda (inst:i8* val:i32)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note osc1_wave val i32)
      void)))

(bind-func get_osc1_wave
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note osc1_wave i32))))

(bind-func set_osc2_pan
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note osc2_pan val float)
      void)))

(bind-func get_osc2_pan
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note osc2_pan float))))

(bind-func set_osc2_amp
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note osc2_amp val float)
      void)))

(bind-func get_osc2_amp
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note osc2_amp float))))

(bind-func set_osc2_tune
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note tune2 val float)
      void)))

(bind-func get_osc2_tune
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note tune2 float))))

(bind-func set_osc2_pw
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note pw2 val float)
      void)))

(bind-func get_osc2_pw
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note pw2 float))))

(bind-func set_osc2_wave
  (lambda (inst:i8* val:i32)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note osc2_wave val i32)
      void)))

(bind-func get_osc2_wave
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note osc2_wave i32))))

(bind-func set_osc3_pan
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note osc3_pan val float)
      void)))

(bind-func get_osc3_pan
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note osc3_pan float))))

(bind-func set_osc3_amp
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note osc3_amp val float)
      void)))

(bind-func get_osc3_amp
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note osc3_amp float))))

(bind-func set_osc3_tune
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note tune3 val float)
      void)))

(bind-func get_osc3_tune
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note tune3 float))))

(bind-func set_osc3_pw
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note pw3 val float)
      void)))

(bind-func get_osc3_pw
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note pw3 float))))

(bind-func set_osc3_wave
  (lambda (inst:i8* val:i32)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note osc3_wave val i32)
      void)))

(bind-func get_osc3_wave
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note osc3_wave i32))))

(bind-func set_osc4_pan
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note osc4_pan val float)
      void)))

(bind-func get_osc4_pan
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note osc4_pan float))))

(bind-func set_osc4_amp
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note osc4_amp val float)
      void)))

(bind-func get_osc4_amp
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note osc4_amp float))))

(bind-func set_osc4_tune
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note tune4 val float)
      void)))

(bind-func get_osc4_tune
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note tune4 float))))

(bind-func set_osc4_pw
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note pw4 val float)
      void)))

(bind-func get_osc4_pw
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note pw4 float))))

(bind-func set_osc4_wave
  (lambda (inst:i8* val:i32)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note osc4_wave val i32)
      void)))

(bind-func get_osc4_wave
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note osc4_wave i32))))

(bind-func set_sub_pan
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note sub_pan val float)
      void)))

(bind-func get_sub_pan
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note sub_pan float))))

(bind-func set_sub_amp
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note sub_amp val float)
      void)))

(bind-func get_sub_amp
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note sub_amp float))))

(bind-func set_noise_pan
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note noise_pan val float)
      void)))

(bind-func get_noise_pan
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note noise_pan float))))

(bind-func set_noise_type
  (lambda (inst:i8* val:i32)  
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note noise val enum)
      void)))

(bind-func get_noise_type
  (lambda (inst:i8*)  
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note noise enum))))

(bind-func set_noise_amp
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note noise_amp val float)
      void)))

(bind-func get_noise_amp
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note noise_amp float))))

(bind-func set_cutoff
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note filter_frq val float)
      void)))

(bind-func get_cutoff
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note filter_frq float))))

(bind-func set_filter_cutoff
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note filter_frq val float)
      void)))

(bind-func get_filter_cutoff
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note filter_frq float))))

(bind-func set_filter_frq (lambda (inst:i8* val:float) (set_filter_cutoff inst val)))
(bind-func get_filter_frq (lambda (inst:i8*) (get_filter_cutoff inst)))

(bind-func set_lpf_frq (lambda (inst:i8* val:float) (set_filter_cutoff inst val)))
(bind-func get_lpf_frq (lambda (inst:i8*) (get_filter_cutoff inst)))

(bind-func set_lpf_cutoff (lambda (inst:i8* val:float) (set_filter_cutoff inst val)))
(bind-func get_lpf_cutoff (lambda (inst:i8*) (get_filter_cutoff inst)))

(bind-func set_filter_type
  (lambda (inst:i8* val:i32)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note filter_type (convert val i64) i64)
      void)))

(bind-func get_filter_type
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (i64toi32 (cref note filter_type i64)))))

(bind-func set_filter_res
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note reso val float)
      void)))

(bind-func get_filter_res
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note reso float))))

(bind-func set_lpf_res
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note reso val float)
      void)))

(bind-func get_lpf_res
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note reso float))))

(bind-func set_amp_env
  (lambda (inst:i8* a:float d s r)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note amp_env (array a d s r) |4,float|)
      void)))

(bind-func get_amp_env
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note amp_env |4,float|))))

(bind-func get_amp_env_attack
  (lambda (inst:i8*)
    (aref (get_amp_env inst) 0)))

(bind-func set_amp_env_attack
  (lambda (inst:i8* a:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*))
          (env (get_amp_env inst)))
      (aset! (ref env) 0 a)
      (cset! note filter_env env |4,float|)
      void)))

(bind-func get_amp_env_decay
  (lambda (inst:i8*)
    (aref (get_amp_env inst) 1)))

(bind-func set_amp_env_decay
  (lambda (inst:i8* d:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*))
          (env (get_amp_env inst)))
      (aset! (ref env) 1 d)
      (cset! note filter_env env |4,float|)
      void)))

(bind-func get_amp_env_sustain
  (lambda (inst:i8*)
    (aref (get_amp_env inst) 2)))

(bind-func set_amp_env_sustain
  (lambda (inst:i8* s:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*))
          (env (get_amp_env inst)))
      (aset! (ref env) 2 s)
      (cset! note filter_env env |4,float|)
      void)))
  
(bind-func get_amp_env_release
  (lambda (inst:i8*)
    (aref (get_amp_env inst) 3)))

(bind-func set_amp_env_release
  (lambda (inst:i8* r:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*))
          (env (get_amp_env inst)))
      (aset! (ref env) 3 r)
      (cset! note filter_env env |4,float|)
      void)))

(bind-func set_mod_env
  (lambda (inst:i8* a:float d s r)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note mod_env (array a d s r) |4,float|)
      void)))

(bind-func get_mod_env
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note mod_env |4,float|))))

(bind-func get_mod_env_attack
  (lambda (inst:i8*)
    (aref (get_mod_env inst) 0)))

(bind-func set_mod_env_attack
  (lambda (inst:i8* a:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*))
          (env (get_mod_env inst)))
      (aset! (ref env) 0 a)
      (cset! note filter_env env |4,float|)
      void)))

(bind-func get_mod_env_decay
  (lambda (inst:i8*)
    (aref (get_mod_env inst) 1)))

(bind-func set_mod_env_decay
  (lambda (inst:i8* d:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*))
          (env (get_mod_env inst)))
      (aset! (ref env) 1 d)
      (cset! note filter_env env |4,float|)
      void)))

(bind-func get_mod_env_sustain
  (lambda (inst:i8*)
    (aref (get_mod_env inst) 2)))

(bind-func set_mod_env_sustain
  (lambda (inst:i8* s:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*))
          (env (get_mod_env inst)))
      (aset! (ref env) 2 s)
      (cset! note filter_env env |4,float|)
      void)))

(bind-func get_mod_env_release
  (lambda (inst:i8*)
    (aref (get_mod_env inst) 3)))

(bind-func set_mod_env_release
  (lambda (inst:i8* r:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*))
          (env (get_mod_env inst)))
      (aset! (ref env) 3 r)
      (cset! note filter_env env |4,float|)
      void)))

(bind-func set_filter_env
  (lambda (inst:i8* a:float d s r)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note filter_env (array a d s r) |4,float|)
      void)))

(bind-func get_filter_env
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note filter_env |4,float|))))

(bind-func get_filter_env_attack
  (lambda (inst:i8*)
    (aref (get_filter_env inst) 0)))

(bind-func set_filter_env_attack
  (lambda (inst:i8* a:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*))
          (env (get_filter_env inst)))
      (aset! (ref env) 0 a)
      (cset! note filter_env env |4,float|)
      void)))

(bind-func get_filter_env_decay
  (lambda (inst:i8*)
    (aref (get_filter_env inst) 1)))

(bind-func set_filter_env_decay
  (lambda (inst:i8* d:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*))
          (env (get_filter_env inst)))
      (aset! (ref env) 1 d)
      (cset! note filter_env env |4,float|)
      void)))

(bind-func get_filter_env_sustain
  (lambda (inst:i8*)
    (aref (get_filter_env inst) 2)))

(bind-func set_filter_env_sustain
  (lambda (inst:i8* s:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*))
          (env (get_filter_env inst)))
      (aset! (ref env) 2 s)
      (cset! note filter_env env |4,float|)
      void)))

(bind-func get_filter_env_release
  (lambda (inst:i8*)
    (aref (get_filter_env inst) 3)))

(bind-func set_filter_env_release
  (lambda (inst:i8* r:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*))
          (env (get_filter_env inst)))
      (aset! (ref env) 3 r)
      (cset! note filter_env env |4,float|)
      void)))

(bind-func set_filter_env_amt
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note filter_env_amt val float)
      void)))

(bind-func get_filter_env_amt
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note filter_env_amt float))))

(bind-func set_pitch_env
  (lambda (inst:i8* a:float d)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note pitch_env (array a d) |2,float|)
      void)))

(bind-func get_pitch_env
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note pitch_env |2,float|))))

(bind-func get_pitch_env_attack
  (lambda (inst:i8*)
    (aref (get_pitch_env inst) 0)))

(bind-func set_pitch_env_attack
  (lambda (inst:i8* a:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*))
          (env (get_pitch_env inst)))
      (aset! (ref env) 0 a)
      (cset! note filter_env env |2,float|)
      void)))

(bind-func get_pitch_env_decay
  (lambda (inst:i8*)
    (aref (get_pitch_env inst) 1)))

(bind-func set_pitch_env_decay
  (lambda (inst:i8* d:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*))
          (env (get_pitch_env inst)))
      (aset! (ref env) 1 d)
      (cset! note filter_env env |2,float|)
      void)))

(bind-func set_pitch_env_amt
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note pitch_env_amt val float)
      void)))

(bind-func get_pitch_env_amt
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note pitch_env_amt float))))

(bind-func set_filter_env_follow_frq
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note follow_frq val float)
      void)))

(bind-func get_filter_env_follow_frq
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note follow_frq float))))

(bind-func set_filter_env_follow_amp
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note follow_amp val float)
      void)))

(bind-func get_filter_env_follow_amp
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note follow_amp float))))

;; filter drive
(bind-func set_filter_drive
  (lambda (inst:i8* val:float)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cset! note filter_saturation val float)
      void)))

(bind-func get_filter_drive
  (lambda (inst:i8*)
    (let ((note (cref (cast inst [void]*) note_kernel [void]*)))
      (cref note filter_saturation float))))



;;
;; fx kernel params for ALL instruments
;;

(bind-func set_gain
  (lambda (inst:i8* val:float)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! effect gain val float)
      void)))

(bind-func get_gain
  (lambda (inst:i8*)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref effect gain float))))

(bind-func set_hpf_frq
  (lambda (inst:i8* val:float)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! effect hpf_frq val float)
      void)))

(bind-func get_hpf_frq
  (lambda (inst:i8*)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref effect hpf_frq float))))

(bind-func set_delay_time
  (lambda (inst:i8* val:float)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! effect delay_time_left val float)
      (cset! effect delay_time_right val float)      
      void)))

(bind-func get_delay_time
  (lambda (inst:i8*)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (array (cref effect delay_time_left float)
             (cref effect delay_time_right float)))))

(bind-func set_delay_time_left
  (lambda (inst:i8* val:float)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! effect delay_time_left val float)
      void)))

(bind-func get_delay_time_left
  (lambda (inst:i8*)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref effect delay_time_left float))))

(bind-func set_delay_time_right
  (lambda (inst:i8* val:float)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! effect delay_time_right val float)
      void)))

(bind-func get_delay_time_right
  (lambda (inst:i8*)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref effect delay_time_right float))))

(bind-func set_delay_mix
  (lambda (inst:i8* val:float)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! effect delay_mix val float)
      void)))

(bind-func get_delay_mix
  (lambda (inst:i8*)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref effect delay_mix float))))

(bind-func set_delay_fb
  (lambda (inst:i8* val:float)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! effect delay_fb val float)
      void)))

(bind-func get_delay_fb
  (lambda (inst:i8*)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref effect delay_fb float))))

(bind-func set_delay_frq
  (lambda (inst:i8* val:float)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! effect delay_frq val float)
      void)))

(bind-func get_delay_frq
  (lambda (inst:i8*)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref effect delay_frq float))))

(bind-func set_delay_res
  (lambda (inst:i8* val:float)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! effect delay_res val float)
      void)))

(bind-func get_delay_res
  (lambda (inst:i8*)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref effect delay_res float))))

(bind-func set_overdrive_amt
  (lambda (inst:i8* val:float)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! effect overdrive_amt val float)
      void)))

(bind-func get_overdrive_amt
  (lambda (inst:i8* val:float)
    (let ((effect (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref effect overdrive_amt float))))

(bind-func set_lfo_ad
  (lambda (inst:i8* lfo_num:i32 attack:float decay:float a_slope:float d_slope:float)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*))
          (mod_attack (cref fx mod_attack |4,float|*))
          (mod_decay (cref fx mod_decay |4,float|*))
          (mod_attack_slope (cref fx mod_attack_slope |4,float|*))
          (mod_decay_slope (cref fx mod_decay_slope |4,float|*)))
      (aset! mod_attack lfo_num attack)
      (aset! mod_decay lfo_num decay)
      (aset! mod_attack_slope lfo_num a_slope)
      (aset! mod_decay_slope lfo_num d_slope)
      void)))

(bind-func get_lfo_ad
  (lambda (inst:i8* lfo_num:i32)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*))
          (mod_attack (cref fx mod_attack |4,float|*))
          (mod_decay (cref fx mod_decay |4,float|*))
          (mod_attack_slope (cref fx mod_attack_slope |4,float|*))
          (mod_decay_slope (cref fx mod_decay_slope |4,float|*)))
      (array (aref mod_attack lfo_num)
             (aref mod_decay lfo_num)
             (aref mod_attack_slope lfo_num)
             (aref mod_decay_slope lfo_num)))))

(bind-func get_lfo_ad_attack
  (lambda (inst:i8* lfo_num:i32)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*))
          (mod_attack (cref fx mod_attack |4,float|*)))
      (aref mod_attack lfo_num))))

(bind-func get_lfo_ad_decay
  (lambda (inst:i8* lfo_num:i32)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*))
          (mod_decay (cref fx mod_decay |4,float|*)))
      (aref mod_decay lfo_num))))

(bind-func get_lfo_ad_attack_slope
  (lambda (inst:i8* lfo_num:i32)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*))
          (mod_attack_slope (cref fx mod_attack_slope |4,float|*)))
        (aref mod_attack_slope lfo_num))))

(bind-func get_lfo_ad_decay_slope
  (lambda (inst:i8* lfo_num:i32)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*))
          (mod_decay_slope (cref fx mod_decay_slope |4,float|*)))
      (aref mod_decay_slope lfo_num))))


(bind-func set_lfo
  (lambda (inst:i8* lfo_num:i32 amp:float frq:float)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*))
          (mod_amp (cref fx mod_amp |4,float|*))
          (mod_frq (cref fx mod_frq |4,float|*)))
      (aset! mod_amp lfo_num amp)
      (aset! mod_frq lfo_num frq)
      void)))

(bind-func get_lfo
  (lambda (inst:i8* lfo_num:i32)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*))
          (mod_amp (cref fx mod_amp |4,float|*))
          (mod_frq (cref fx mod_frq |4,float|*)))
      (array (aref mod_amp lfo_num)
             (aref mod_frq lfo_num)))))

(bind-func get_lfo_attack
  (lambda (inst:i8* lfo_num:i32)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*))
          (mod_amp (cref fx mod_amp |4,float|*))
          (mod_frq (cref fx mod_frq |4,float|*)))
      (aref mod_amp lfo_num))))

(bind-func get_lfo_decay
  (lambda (inst:i8* lfo_num:i32)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*))
          (mod_amp (cref fx mod_amp |4,float|*))
          (mod_frq (cref fx mod_frq |4,float|*)))
      (aref mod_frq lfo_num))))

(bind-func set_lfo_type
  (lambda (inst:i8* lfo_num:i32 type:i32)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*))
          (lfo_types (cref fx lfo_types |4,i32|*)))
      (aset! lfo_types lfo_num type)
      void)))

(bind-func get_lfo_type
  (lambda (inst:i8* lfo_num:i32)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*))
          (lfo_types (cref fx lfo_types |4,i32|*)))
      (aref lfo_types lfo_num))))

(bind-func set_pan_width
  (lambda (inst:i8* val:float)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! fx pan_width val float)
      void)))

(bind-func get_pan_width
  (lambda (inst:i8*)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref fx pan_width float))))

(bind-func set_pan_pos
  (lambda (inst:i8* val:float)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! fx pan_pos val float)
      void)))

(bind-func get_pan_pos
  (lambda (inst:i8*)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref fx pan_pos float))))

(bind-func set_reverb_mix
  (lambda (inst:i8* val:float)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! fx reverb_mix val float)
      void)))

(bind-func get_reverb_mix
  (lambda (inst:i8*)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref fx reverb_mix float))))

(bind-func set_reverb_size
  (lambda (inst:i8* val:float)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! fx reverb_size val float)
      void)))

(bind-func get_reverb_size
  (lambda (inst:i8*)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref fx reverb_size float))))

(bind-func set_reverb_absorb
  (lambda (inst:i8* val:float)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! fx reverb_absorb val float)
      void)))

(bind-func get_reverb_absorb
  (lambda (inst:i8*)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref fx reverb_absorb float))))

(bind-func set_reverb_predelay
  (lambda (inst:i8* val:float)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! fx reverb_predelay val float)
      void)))

(bind-func get_reverb_predelay
  (lambda (inst:i8*)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref fx reverb_predelay float))))

(bind-func set_flanger_mix
  (lambda (inst:i8* val:float)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! fx flanger_mix val float)
      void)))

(bind-func get_flanger_mix
  (lambda (inst:i8*)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref fx flanger_mix float))))

(bind-func set_flanger_low
  (lambda (inst:i8* val:float)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! fx flanger_low val float)
      void)))

(bind-func get_flanger_low
  (lambda (inst:i8*)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref fx flanger_low float))))

(bind-func set_flanger_high
  (lambda (inst:i8* val:float)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! fx flanger_high val float)
      void)))

(bind-func get_flanger_high
  (lambda (inst:i8*)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref fx flanger_high float))))

(bind-func set_flanger_rate
  (lambda (inst:i8* val:float)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! fx flanger_rate val float)
      void)))

(bind-func get_flanger_rate
  (lambda (inst:i8*)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref fx flanger_rate float))))

(bind-func set_flanger_fb
  (lambda (inst:i8* val:float)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cset! fx flanger_fb val float)
      void)))

(bind-func get_flanger_fb
  (lambda (inst:i8*)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*)))
      (cref fx flanger_fb float))))


;; modulation matrix

(bind-func set_mod_matrix
  (lambda (inst:i8* src:enum dst:enum value:float)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*))
          (mod_matrix (fx.mod_matrix:|4,|32,SAMPLE||*)))
      (if (< dst 32)
          (aset! (aref-ptr mod_matrix src) dst value))
      value)))

(bind-func get_mod_matrix
  (lambda (inst:i8* src:enum dst:enum)
    (let ((fx (cref (cast inst [void]*) effect_kernel [void]*))
          (mod_matrix (fx.mod_matrix:|4,|32,SAMPLE||*)))
      (if (< dst 32)
          (aref (aref-ptr mod_matrix src) dst)
          0.0))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; instrument definitions
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Basic
;;
;; an example of the most basic instrument possible
;; simply plays back a sine wave
;;
(bind-func basic_note
  (lambda ()
    (lambda (data:NoteData* nargs:i64 dargs:SAMPLE*)
      (let ((starttime (note_starttime data))  ;; start time
            (frequency (note_frequency data))  ;; you'll probably want the note frequency (in hz)
            (amplitude (note_amplitude data))  ;; you'll probably want the note amplitude (0.0-1.0)
            (duration (note_duration data))   ;; you'll probably need the duration (in samples)
            (osc (osc_mc_c 0.0)))
        (lambda (time:i64 chan:i64)
           ;; you are responsible for stopping a note by setting note_running to #f!
          (if (> (- time starttime) duration) (note_active data #f))
          (osc chan amplitude frequency))))))

;; simple fx for basic (adds a stereo delay)
(bind-func basic_fx
  (lambda ()
    (let ((notekernel:NOTE_KERNEL null)
          (gain 1.0)
          (dly (delay_st_c (ftoi64 (* SRf 0.333)) (ftoi64 (* SRf 0.25)))))
      (lambda (in:SAMPLE time:i64 chan:i64 dat:SAMPLE*)
        (if (< chan 2)
            (* gain (dly chan in 0.5 0.5))
            0.0)))))


;; A simple FM synth
;;
;; instrument responds to params
;;
;; set_gain
;; set_amp_env
;; set_delay_fb
;; set_delay_mix
;; set_filter_res
;;

;; You can push I higher than 1.0
;; But only when H is low
;;
(bind-func fmsynth_note
  (lambda ()
    (let ((amp_env:|4,float| (array 10.0:f 50.0 0.6 200.0)))
      (lambda (data:NoteData* nargs:i64 dargs:SAMPLE*)
        (let (;; (gate:SAMPLE 1.0)
              (starttime (note_starttime data))
              (frequency (note_frequency data))
              (amplitude (note_amplitude data))     
              (duration (note_duration data))
              (a (aref amp_env 0))
              (d (aref amp_env 1))
              (s (aref amp_env 2))
              (r (aref amp_env 3))
              (release (convert (* SRs (convert (/ (aref amp_env 3) 1000.0))) i64))
              (o1 (osc_c 0.0))
              (o2 (osc_c 0.0))
              (env (adsr_c))
              (eamp 0.0:f)
              (I (if (> nargs 0) (pref dargs 0) 0.1)) ;; modulation index (generally 0.0-1.0)
              (H (if (> nargs 1) (pref dargs 1) 10.0)) ;; harmonicity ratio (whole numbers 1.0 - 20.0)
              (out:SAMPLE 0.0))
          (lambda (time:i64 chan:i64) ; infreq:SAMPLE inamp:SAMPLE)
            (if (= chan 0)
                (begin
                  (if (> (- time starttime) duration) (note_gate data 0.0))
                  (set! eamp (env chan (note_gate data) a d s r))
                  (if (> (- time starttime) (+ duration release)) (note_active data #f))
                  (set! out (o1 (* (/ 5.0 (log frequency)) (* eamp amplitude))
                                (+ frequency
                                   (o2 (* (* H frequency) I)
                                       (* H frequency)))))))
            (* 1.0 out)))))))


;; fx kernel
;;
(bind-func fmsynth_fx
  (lambda ()
    (let ((notekernel:NOTE_KERNEL null)
          (o1 (osc_c 0.0))
          (o2 (osc_c (* 0.5 SPI)))
          (cl (chorus_c 0.0))
          (cr (chorus_c 0.314))
          (del1 (delay_c (convert (/ (convert SAMPLE_RATE double) 2.0))))
          (del2 (delay_c (convert (/ (convert SAMPLE_RATE double) 3.0))))
          (lpfl (lpf_c))
          (lpfr (lpf_c))
          (reso 0.4)
          (cwet 0.5)
          (cfb 0.5)
          (gain 1.0)
          (delay_mix 0.5)
          (delay_fb 0.5))
      (lambda (in:SAMPLE time:i64 chan:i64 dat:SAMPLE*)
        (cond ((= chan 0)
               (* gain (lpfl (del1 (cl in 1.0 cwet cfb) delay_mix delay_fb)
                             (+ 8000.0 (o1 6000.0 0.3333))
                             reso)))
              ((= chan 1)
               (* gain (lpfr (del2 (cr in 1.0 cwet cfb) delay_mix delay_fb)
                             (+ 8000.0 (o2 6000.0 0.2))
                             reso)))
              (else 0.0))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; a workhorse synthesizer for extempore
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; NOTE
(bind-func analogue_with_mono_note
  (lambda ()
    (let ((MILLISEC (* .001 SRs))
          (amp_env:|4,SAMPLE| (array 10.0:f 10.0 0.6 50.0))
          (filter_env:|4,SAMPLE| (array 10.0:f 10.0 0.6 50.0))
          (pitch_env:|2,SAMPLE| (array 5.0:f 5.0))
          (oldfreq 440.0:f)
          (tune1:SAMPLE 1.0)
          (tune2:SAMPLE 1.0)
          (tune3:SAMPLE 1.0)
          (tune4:SAMPLE 1.0)
          (osc1_wave:enum PARAM_SAW)
          (osc2_wave:enum PARAM_SAW)
          (osc3_wave:enum PARAM_SAW)
          (osc4_wave:enum PARAM_SAW)
          (pw1:SAMPLE 0.5)
          (pw2:SAMPLE 0.5)        
          (pw3:SAMPLE 0.5)                  
          (pw4:SAMPLE 0.5)                  
          (noise:enum PARAM_WHITE) ;; white
          (noise_amp:SAMPLE 0.0)
          (osc1_amp:SAMPLE 0.4)
          (osc2_amp:SAMPLE 0.0)
          (osc3_amp:SAMPLE 0.0)
          (osc4_amp:SAMPLE 0.0)
          (osc1_pan:SAMPLE 0.5)
          (osc2_pan:SAMPLE 0.5)
          (osc3_pan:SAMPLE 0.5)
          (osc4_pan:SAMPLE 0.5)
          (sub_pan:SAMPLE 0.5)
          (noise_pan:SAMPLE 0.5)
          (sub_amp:SAMPLE 0.0) 
          (mods:|32,SAMPLE|* (alloc))
          (noise_amp_mod:SAMPLE 0.0)
          (filter_type:i64 0) ;; LPF 0, BPF 1, HPF 2, Notch 3, Peak 4, APF 5
          (follow_frq 0.0)
          (follow_amp 0.0)
          (filter_saturation:SAMPLE 1.0)
          (legato #f) ;; if legato is true then don't retrigger adsr's!
          (filter_frq:SAMPLE 15000.0) ;; 
          (filter_env_amt:SAMPLE 0.0) ;; this for lpf
          (pitch_env_amt:SAMPLE 0.0)
          (portamento:SAMPLE 2.0) ;; in millis
          (res:SAMPLE 0.0)
          (reso:SAMPLE 0.0))
      (lambda (data:NoteData* nargs:i64 dargs:SAMPLE*)
        ;; (println "NEW NOTE!" data)
        (let ((starttime:i64 (note_starttime data))
              (frequency:SAMPLE (note_frequency data))
              (target_frq:SAMPLE frequency)
              (amplitude:SAMPLE (note_amplitude data))
              (target_amp:SAMPLE amplitude)
              (newampinc:SAMPLE 0.0)
              (duration:i64 (note_duration data))
              (glideinc:SAMPLE 0.0) ;; for portamento
              (midifrq:SAMPLE 0.0)
              (new_note_timer:i64 0)
              (frq 0.0)
              (adsr1 (adsr_c))
              (adsr2 (adsr_c))
              (adsr3 (adsr_c))
              (adsr1_val 0.0)
              (target_adsr1_val 0.0)
              (adsr2_val 0.0)
              (target_adsr2_val 0.0)
              (adsr3_val 0.0)
              (target_adsr3_val 0.0)          
              ;; (gate:SAMPLE 1.0)
              (amp:SAMPLE 0.0)
              (cof:SAMPLE 0.0)
              (amp_attack (aref amp_env 0))
              (amp_decay (aref amp_env 1))
              (amp_sustain (aref amp_env 2))
              (amp_release (aref amp_env 3))
              (amp_release_samples (convert (* SRs (/ amp_release 1000.0)) i64))
              (reltime:i64 0)
              (filter_attack (aref filter_env 0))
              (filter_decay (aref filter_env 1))
              (filter_sustain (aref filter_env 2))
              (filter_release (aref filter_env 3))
              (pitch_attack (aref pitch_env 0))
              (pitch_decay (aref pitch_env 1))
              (filter (svf_c))
              (filterR (svf_c))
              (filter_out:|6,SAMPLE|* (alloc))
              (sin1 (osc_c (* .025 (random))))
              (sin2 (osc_c (* .025 (random))))
              (sin3 (osc_c (* .025 (random))))
              (sin4 (osc_c (* .025 (random))))
              (saw1 (blsaw_c (* .025 (random)) #f #f))
              (saw2 (blsaw_c (* .025 (random)) #f #f))
              (saw3 (blsaw_c (* .025 (random)) #f #f))
              (saw4 (blsaw_c (* .025 (random)) #f #f))
              (pulse1 (blpulse_c 1.0 #f))
              (pulse2 (blpulse_c 1.0 #f))
              (pulse3 (blpulse_c 1.0 #f))
              (pulse4 (blpulse_c 1.0 #f))
              (tri1 (bltri_c 1.0))
              (tri2 (bltri_c 1.0))
              (tri3 (bltri_c 1.0))
              (tri4 (bltri_c 1.0))
              (osc1_out 0.0)
              (osc2_out 0.0)
              (osc3_out 0.0)
              (osc4_out 0.0)
              (zero:SAMPLE 0.0)
              (white (white_c))
              (pink (pink_c))
              (sub_out 0.0)
              (noise_out 0.0)
              (subosc (osc_c 0.0))              
              (main_out 0.0:f))
          (lambda (time:i64 chan:i64)
            (if (= chan 0) 
                (begin
                  ;; this here for mono synths
                  (if (<> starttime (tref data 1))
                      (begin
                        ;; param updates :(
                        (set! amp_attack (aref amp_env 0))
                        (set! amp_decay (aref amp_env 1))
                        (set! amp_sustain (aref amp_env 2))
                        (set! amp_release (aref amp_env 3))
                        (set! amp_release_samples (convert (* SRs (/ amp_release 1000.0)) i64))
                        (set! filter_attack (aref filter_env 0))
                        (set! filter_decay (aref filter_env 1))
                        (set! filter_sustain (aref filter_env 2))
                        (set! filter_release (aref filter_env 3))
                        (set! pitch_attack (aref pitch_env 0))
                        (set! pitch_decay (aref pitch_env 1))
                        ;; now note updates
                        (set! starttime (tref data 1))
                        (set! target_frq (frq2midi (tref data 2)))
                        (set! target_amp (tref data 3))
                        (set! midifrq (frq2midi frequency))
                        (set! reltime 0)
                        (if (< portamento 0.001)
                            (begin (set! frequency target_frq)
                                   (set! glideinc 0.0))
                            (set! glideinc (* (- target_frq midifrq)
                                              (/ 1.0 (* portamento MILLISEC)))))
                        (if (and (> portamento amp_attack)
                                 (> portamento filter_attack))
                            (set! new_note_timer (convert (* portamento MILLISEC) i64))
                            (if (> amp_attack filter_attack)
                                (set! new_note_timer (convert (* amp_attack MILLISEC) i64))
                                (set! new_note_timer (convert (* filter_attack MILLISEC) i64))))
                        (set! newampinc (/ (- target_amp amplitude) (convert new_note_timer)))
                        (set! duration (tref data 4))                 
                        ;; (set! gate 1.0)
                        (if legato
                            (begin
                              (set! target_adsr1_val 0.0)
                              (set! target_adsr2_val 0.0)
                              (set! target_adsr3_val 0.0)
                              void)                                  
                            (begin
                              (if (> adsr1_val target_adsr1_val)
                                  (set! target_adsr1_val adsr1_val))
                              (if (> adsr2_val target_adsr2_val)
                                  (set! target_adsr2_val adsr2_val))
                              (if (> adsr3_val target_adsr3_val)
                                  (set! target_adsr3_val adsr3_val))
                              (retrigger_adsr adsr1)
                              (retrigger_adsr adsr2)
                              (retrigger_adsr adsr3)
                              void))
                        ;; (println "START:" starttime "FRQ:" target_frq "AMPAKT:" amp_attack "FATTK:" filter_attack "A1:" target_adsr1_val "A2:" target_adsr2_val)                        
                        void))
                  ;;;;;;;;mono;;;mono;;;mono;;;;;;;;
                  (if (and (> (note_gate data) 0.5) (> (- time starttime) duration)) (note_gate data 0.0)) ;; (set! gate 0.0))
                  (set! adsr1_val (adsr1 chan (note_gate data) amp_attack amp_decay amp_sustain amp_release))
                  (set! adsr2_val (adsr2 chan (note_gate data) filter_attack filter_decay filter_sustain filter_release))
                  (set! adsr3_val (adsr3 chan (note_gate data) pitch_attack pitch_decay 0.0 0.0))
                  ;;;; this needed for mono synths
                  (if (> new_note_timer 0) ;; try to minimize the amount of work needed for monosynths :(
                      (begin
                        (if (< glideinc 0.0) ;; this for portamento
                            (if (< (- target_frq midifrq) glideinc)
                                (set! midifrq (+ glideinc midifrq))
                                (set! midifrq target_frq))
                            (if (> (- target_frq midifrq) glideinc)
                                (set! midifrq (+ glideinc midifrq))
                                (set! midifrq target_frq)))
                        (set! amplitude (+ amplitude newampinc))
                        (set! frequency (midi2frq midifrq))
                        (if (< adsr1_val target_adsr1_val)
                            (set! adsr1_val target_adsr1_val)
                            (set! target_adsr1_val 0.0))
                        (if (< adsr2_val target_adsr2_val)
                            (set! adsr2_val target_adsr2_val)
                            (set! target_adsr2_val 0.0))
                        (set! new_note_timer (- new_note_timer 1))))
                  ;;;;;;;;;mono;;;mono;;;;;;;;
                  (set! amp (* amplitude adsr1_val))
                  (set! cof (clamp (+ filter_frq (* follow_frq frequency) (* follow_amp amplitude)
                                      (aref mods PARAM_FILTER_FRQ)
                                      (* filter_env_amt adsr2_val))
                                   0.0 22000.0))
                  (set! res (+ reso (aref mods PARAM_FILTER_RES)))
                  (set! frq (+ frequency (* pitch_env_amt frequency adsr3_val) 0.0))
                  (if (< frq 10.0) (set! frq 10.0))
                  ;; if gate is OFF and amp is sufficiently close to 0.0 then stop note!
                  (if (< (note_gate data) 0.1) (set! reltime (+ reltime 1)))
                  (if (> reltime amp_release_samples)
                      (begin
                        ;; (println "NOTE OFF!" data)
                        (note_active data #f)))
                  ;; (if (and (< gate 0.5) (< amp 0.00001)) (note_active data #f))
                  ;; setup mod sources
                  (if (> osc1_amp 0.001)
                      (set! osc1_out (* (+ osc1_amp (aref mods PARAM_OSC1_AMP))
                                        (cond ((= osc1_wave 0) (sin1 1.0 (+ (* tune1 frq) (aref mods PARAM_OSC1_FRQ))))
                                              ((= osc1_wave 1) (saw1 1.0 (+ (* tune1 frq) (aref mods PARAM_OSC1_FRQ))))
                                              ((= osc1_wave 2) (pulse1 1.0 (+ (* tune1 frq) (aref mods PARAM_OSC1_FRQ))
                                                                       (+ pw1 (aref mods PARAM_OSC1_PW))))
                                              ((= osc1_wave 3) (tri1 1.0 (+ (* tune1 frq) (aref mods PARAM_OSC1_FRQ))))
                                              (else zero))))
                      (set! osc1_out 0.0))
                  (if (> osc2_amp 0.001)
                      (set! osc2_out (* (+ osc2_amp (aref mods PARAM_OSC2_AMP))
                                        (cond ((= osc2_wave 0) (sin2 1.0 (+ (* tune2 frq) (aref mods PARAM_OSC2_FRQ))))
                                              ((= osc2_wave 1) (saw2 1.0 (+ (* tune2 frq) (aref mods PARAM_OSC2_FRQ))))
                                              ((= osc2_wave 2) (pulse2 1.0 (+ (* tune2 frq) (aref mods PARAM_OSC2_FRQ))
                                                                       (+ pw2 (aref mods PARAM_OSC2_PW))))
                                              ((= osc2_wave 3) (tri2 1.0 (+ (* tune2 frq) (aref mods PARAM_OSC2_FRQ))))
                                              (else zero))))
                      (set! osc2_out 0.0))
                  (if (> osc3_amp 0.001)
                      (set! osc3_out (* (+ osc3_amp (aref mods PARAM_OSC3_AMP))
                                        (cond ((= osc3_wave 0) (sin3 1.0 (+ (* tune3 frq) (aref mods PARAM_OSC3_FRQ))))
                                              ((= osc3_wave 1) (saw3 1.0 (+ (* tune3 frq) (aref mods PARAM_OSC3_FRQ))))
                                              ((= osc3_wave 2) (pulse3 1.0 (+ (* tune3 frq) (aref mods PARAM_OSC3_FRQ))
                                                                       (+ pw3 (aref mods PARAM_OSC3_PW))))
                                              ((= osc3_wave 3) (tri3 1.0 (+ (* tune3 frq) (aref mods PARAM_OSC3_FRQ))))
                                              (else zero))))
                      (set! osc3_out 0.0))
                  (if (> osc4_amp 0.001)
                      (set! osc4_out (* (+ osc4_amp (aref mods PARAM_OSC4_AMP))
                                        (cond ((= osc4_wave 0) (sin4 1.0 (+ (* tune4 frq) (aref mods PARAM_OSC4_FRQ))))
                                              ((= osc4_wave 1) (saw4 1.0 (+ (* tune4 frq) (aref mods PARAM_OSC4_FRQ))))
                                              ((= osc4_wave 2) (pulse4 1.0 (+ (* tune4 frq) (aref mods PARAM_OSC4_FRQ))
                                                                       (+ pw4 (aref mods PARAM_OSC4_PW))))
                                              ((= osc4_wave 3) (tri4 1.0 (+ (* tune4 frq) (aref mods PARAM_OSC4_FRQ))))
                                              (else zero))))
                      (set! osc4_out 0.0))
                  (if (> sub_amp 0.001)
                      (set! sub_out (* sub_amp (subosc 1.0 (* frq 0.25))))
                      (set! sub_out 0.0))
                  (if (> noise_amp 0.001)
                      (if (= noise PARAM_WHITE)
                          (set! noise_out (* 0.5 (+ noise_amp (aref mods PARAM_NOISE_AMP)) (white)))
                          (set! noise_out (* 0.5 (+ noise_amp (aref mods PARAM_NOISE_AMP)) (pink))))
                      (set! noise_out 0.0))))
            (if (= chan 0)
                (begin
                  (filter (* amp (+ (* osc1_out osc1_pan)
                                    (* osc2_out osc2_pan)
                                    (* osc3_out osc3_pan)
                                    (* osc4_out osc4_pan)
                                    (* sub_out sub_pan)
                                    (* noise_out noise_pan)))
                          cof reso
                          filter_out)
                  (set! main_out (aref filter_out filter_type))
                  main_out)
                (if (= chan 1)
                    (begin
                      (filterR (* amp (+ (* osc1_out (- 1.0 osc1_pan))
                                         (* osc2_out (- 1.0 osc2_pan))
                                         (* osc3_out (- 1.0 osc3_pan))
                                         (* osc4_out (- 1.0 osc4_pan))
                                         (* sub_out (- 1.0 sub_pan))
                                         (* noise_out (- 1.0 noise_pan))))
                               cof reso
                               filter_out)
                      (set! main_out (aref filter_out filter_type))
                      main_out)
                    0.0))))))))


;; FX
(bind-func analogue_with_mono_fx
  (let ((MILLISEC (* .001 SRf))
        (CHANSF (i32tof CHANNELS)))
    (lambda ()
      (let ((notekernel:NOTE_KERNEL null)            
            (mod_amp:|4,SAMPLE|* (array_ref 1.0 1.0 1.0 1.0))
            (mod_frq:|4,SAMPLE|* (array_ref 1.0 1.0 1.0 1.0))
            (mod_attack:|4,SAMPLE|* (array_ref 10.0 10.0 10.0 10.0)) ;; in millis
            (mod_decay:|4,SAMPLE|* (array_ref 10.0 10.0 10.0 10.0))
            (mod_attack_slope:|4,SAMPLE|* (array_ref 0.0 0.0 0.0 0.0)) ;; between -1.0 log and 1.0 exp  (0.0 is linear)
            (mod_decay_slope:|4,SAMPLE|* (array_ref 0.0 0.0 0.0 0.0))
            (mods:|32,SAMPLE|* null) ;(alloc))
            (mod_matrix:|4,|32,SAMPLE||* (alloc))
            (tmpmod:|32,SAMPLE|* null)
            (lfos:|4,|5,[SAMPLE,i64,i64]*||* (alloc))
            (lfo_types:|4,i32|* (alloc))
            (hpf (hpf_c))
            (hpfR (hpf_c))
            (hpf_frq 20001.0)
            (dly (comb_lpf_mc_c (i32toi64 CHANNELS) (* SR 120))) ;; max 120 sec delay     
            (delay_time_left 50.0) ;; in ms
            (delay_time_right 50.0) ;; in ms
            (delay_in 1.0)
            (delay_mix 0.0)
            (delay_fb 0.5)
            (delay_frq 12000.0)
            (delay_res 0.0)
            (rev (reverb_st_c))
            (reverb_mix 0.0)
            (reverb_predelay 40.0) ;; in ms
            (reverb_size 0.3)
            (reverb_absorb 0.45)
            (pan (pan_c (i32toi64 CHANNELS)))
            (pan_pos 0.5)          
            (pan_width 1.0)
            (flanger (flanger_st_c))
            (flanger_low 0.1)
            (flanger_high 15.0)
            (flanger_rate 1.0)
            (flanger_fb 0.0)
            (flanger_mix 0.0)
            (overdrive (overdrive_c))
            (overdrive_amt 0.5) ;; always use some overdrive
            (out:SAMPLE 0.0)
            (i:i64 0) (j:i64 0)
            (tmp 0.0)
            (fxout 0.0)
            (gain 2.0))
        (dotimes (i 4)
          (aset! lfo_types i PARAM_SINE)
          (aset! lfos i
                 (array (let ((osc (osc_c 0.0)))
                          (lambda (chan:i64 idx:i64)
                            (osc (aref mod_amp idx)
                                 (aref mod_frq idx))))
                        (let ((osc (saw_c 0.0)))
                          (lambda (chan:i64 idx:i64)
                            (osc (aref mod_amp idx)
                                 (aref mod_frq idx))))
                        (let ((osc (pulse_c 0.0)))
                          (lambda (chan:i64 idx:i64)
                            (osc (aref mod_amp idx)
                                 (aref mod_frq idx)
                                 0.5)))
                        (let ((osc (tri_c 0.0)))
                          (lambda (chan:i64 idx:i64)
                            (osc (aref mod_amp idx)
                                 (aref mod_frq idx))))
                        (let ((osc (ad_c)))
                          (cset! osc cycle #t i1)
                          (lambda (chan:i64 idx:i64)
                            (osc chan 1.0
                                 (aref mod_attack idx)
                                 (aref mod_decay idx)
                                 (aref mod_attack_slope idx)
                                 (aref mod_decay_slope idx)))))))
        (lambda (in:SAMPLE time:i64 chan:i64 dat:SAMPLE*)
          ;; calc mod matrix changes
          (begin
            (if (= mods null) (set! mods (notekernel.mods:|32,SAMPLE|*)))
            (memset (cast mods i8*) 0 128) ;(size_of mods))
            (dotimes (i 4)
              (set! tmp ((aref (aref-ptr lfos i) (aref lfo_types i)) chan i))
              (set! tmpmod (aref-ptr mod_matrix i))
              (dotimes (j 32) (aset! mods j (+ (aref mods j) (* tmp (aref tmpmod j)))))
              void))
          ;; sound in for channel 1
          (if (= chan 0)
              (begin
                (set! out in)
                (set! out (overdrive out overdrive_amt))
                (if (< hpf_frq 20000.0)
                    (set! out (hpf out hpf_frq 0.0)))
                out))
          ;; sound in for channel 2
          (if (= chan 1)
              (begin
                (set! out in)
                (set! out (overdrive out overdrive_amt))
                (if (< hpf_frq 20000.0)
                    (set! out (hpfR out hpf_frq 0.0)))
                out))
          ;; apply FX to both channels 1 and 2
          (set! tmp (+ pan_pos (aref mods PARAM_PAN_POS)))
          (if (> tmp CHANSF) (set! tmp (- tmp CHANSF)))
          ;; always with the panning!
          (set! fxout (pan chan out
                           (+ pan_width (aref mods PARAM_PAN_WIDTH))
                           tmp))
          (if (> flanger_mix 0.001)
              (set! fxout (flanger chan fxout
                                   1.0 flanger_mix
                                   (* MILLISEC (+ flanger_low 0.0)) ;(aref mods PARAM_FLANGER_LOW)))
                                   (* MILLISEC (+ flanger_high 0.0)) ;(aref mods PARAM_FLANGER_HIGH)))
                                   (+ flanger_rate 0.0) ;(aref mods PARAM_FLANGER_RATE))
                                   (+ flanger_fb 0.0)))) ;;(aref mods PARAM_FLANGER_FB)))))
          (if (> delay_mix 0.001)
              (set! fxout (dly chan fxout
                               (if (= chan 0)
                                   (* MILLISEC (+ delay_time_left (aref mods PARAM_DELAY_TIME_LEFT)))
                                   (* MILLISEC (+ delay_time_right (aref mods PARAM_DELAY_TIME_RIGHT))))
                               delay_in
                               delay_mix
                               (+ delay_fb (aref mods PARAM_DELAY_FB))
                               delay_frq
                               delay_res)))
          (if (> reverb_mix 0.001)
              (set! fxout (rev chan fxout
                               (+ reverb_size (aref mods PARAM_REVERB_SIZE))
                               (+ reverb_predelay (aref mods PARAM_REVERB_PREDELAY))
                               (+ reverb_absorb (aref mods PARAM_REVERB_ABSORB))
                               (+ reverb_mix (aref mods PARAM_REVERB_MIX)))))
          (* gain fxout))))))




;; NOTE
(bind-func analogue_note
  (lambda ()
    (let ((MILLISEC (* .001 SRs))
          (amp_env:|4,SAMPLE| (array 0.0:f 0.0 1.0 0.0))
          (filter_env:|4,SAMPLE| (array 0.0:f 0.0 1.0 0.0))
          (pitch_env:|2,SAMPLE| (array 0.0:f 0.0))
          (mod_env:|4,SAMPLE| (array 0.0:f 0.0 1.0 0.0))
          (oldfreq 440.0:f)
          (tune1:SAMPLE 1.0)
          (tune2:SAMPLE 1.0)
          (tune3:SAMPLE 1.0)
          (tune4:SAMPLE 1.0)
          (osc1_wave:enum PARAM_SAW)
          (osc2_wave:enum PARAM_SAW)
          (osc3_wave:enum PARAM_SAW)
          (osc4_wave:enum PARAM_SAW)
          (pw1:SAMPLE 0.5)
          (pw2:SAMPLE 0.5)        
          (pw3:SAMPLE 0.5)                  
          (pw4:SAMPLE 0.5)                  
          (noise:enum PARAM_WHITE) ;; white
          (noise_amp:SAMPLE 0.0)
          (osc1_amp:SAMPLE 0.4)
          (osc2_amp:SAMPLE 0.0)
          (osc3_amp:SAMPLE 0.0)
          (osc4_amp:SAMPLE 0.0)
          (osc1_pan:SAMPLE 0.5)
          (osc2_pan:SAMPLE 0.5)
          (osc3_pan:SAMPLE 0.5)
          (osc4_pan:SAMPLE 0.5)
          (sub_pan:SAMPLE 0.5)
          (noise_pan:SAMPLE 0.5)
          (sub_amp:SAMPLE 0.0) 
          (mods:|32,SAMPLE|* (alloc))
          (noise_amp_mod:SAMPLE 0.0)
          (filter_type:i64 2) ;; LPF2 LPF4, HPF2 HPF4, BPF2 BPF4
          (follow_frq 0.0)
          (follow_amp 0.0)
          (legato #f) ;; if legato is true then don't retrigger adsr's!
          (filter_frq:SAMPLE 15000.0) ;; 
          (filter_env_amt:SAMPLE 0.0) ;; this for lpf
          (filter_saturation:SAMPLE 1.0)
          (pitch_env_amt:SAMPLE 0.0)
          (portamento:SAMPLE 2.0) ;; in millis
          (res:SAMPLE 0.0)
          (reso:SAMPLE 0.0))
      (lambda (data:NoteData* nargs:i64 dargs:SAMPLE*)
        ;; (println "NEW NOTE!" data)
        (let ((starttime:i64 (note_starttime data))
              (frequency:SAMPLE (note_frequency data))
              (target_frq:SAMPLE frequency)
              (amplitude:SAMPLE (note_amplitude data))
              (target_amp:SAMPLE amplitude)
              (newampinc:SAMPLE 0.0)
              (duration:i64 (note_duration data))
              (glideinc:SAMPLE 0.0) ;; for portamento
              (midifrq:SAMPLE 0.0)
              (new_note_timer:i64 0)
              (frq 0.0)
              (adsr1 (adsr_c))
              (adsr2 (adsr_c))
              (adsr3 (adsr_c))
              (adsr4 (adsr_c))
              (adsr1_val 0.0)
              (adsr2_val 0.0)
              (adsr3_val 0.0)
              (adsr4_val 0.0)
              ;; (gate:SAMPLE 1.0)
              (amp:SAMPLE 0.0)
              (cof:SAMPLE 0.0)
              (amp_attack (aref amp_env 0))
              (amp_decay (aref amp_env 1))
              (amp_sustain (aref amp_env 2))
              (amp_release (+ 3.0 (aref amp_env 3))) ;; a 3ms release minimum 
              (amp_release_samples (convert (* SRs (/ amp_release 1000.0)) i64))
              (reltime:i64 0)
              (filter_attack (aref filter_env 0))
              (filter_decay (aref filter_env 1))
              (filter_sustain (aref filter_env 2))
              (filter_release (aref filter_env 3))
              (pitch_attack (aref pitch_env 0))
              (pitch_decay (aref pitch_env 1))
              (mod_attack (aref mod_env 0))
              (mod_decay (aref mod_env 1))
              (mod_sustain (aref mod_env 2))
              (mod_release (aref mod_env 3))
              (filter (moog_ladder (i64toi32 filter_type)))
              (filterR (moog_ladder (i64toi32 filter_type)))
              (sin1 (osc_c (* .025 (random))))
              (sin2 (osc_c (* .025 (random))))
              (sin3 (osc_c (* .025 (random))))
              (sin4 (osc_c (* .025 (random))))
              (saw1 (blsaw_c (* .025 (random)) #f #f))
              (saw2 (blsaw_c (* .025 (random)) #f #f))
              (saw3 (blsaw_c (* .025 (random)) #f #f))
              (saw4 (blsaw_c (* .025 (random)) #f #f))
              (pulse1 (blpulse_c 1.0 #f))
              (pulse2 (blpulse_c 1.0 #f))
              (pulse3 (blpulse_c 1.0 #f))
              (pulse4 (blpulse_c 1.0 #f))
              (tri1 (bltri_c 1.0))
              (tri2 (bltri_c 1.0))
              (tri3 (bltri_c 1.0))
              (tri4 (bltri_c 1.0))
              (osc1_out 0.0)
              (osc2_out 0.0)
              (osc3_out 0.0)
              (osc4_out 0.0)
              (zero:SAMPLE 0.0)
              (white (white_c))
              (pink (pink_c))
              (sub_out 0.0)
              (noise_out 0.0)
              (subosc (osc_c 0.0))              
              (main_out 0.0:f))
          (filter.saturation (clamp filter_saturation 1.0:f 3.0:f))
          (filterR.saturation (clamp filter_saturation 1.0:f 3.0:f))
          (lambda (time:i64 chan:i64)
            (if (= chan 0) 
                (begin
                  (if (and (> (note_gate data) 0.5) (> (- time starttime) duration)) (note_gate data 0.0)) ;; (set! gate 0.0))
                  (set! adsr1_val (adsr1 chan (note_gate data) amp_attack amp_decay amp_sustain amp_release))
                  (set! adsr2_val (adsr2 chan (note_gate data) filter_attack filter_decay filter_sustain filter_release))
                  (set! adsr3_val (adsr3 chan (note_gate data) pitch_attack pitch_decay 0.0 0.0))
                  (set! adsr4_val (adsr4 chan (note_gate data) mod_attack mod_decay mod_sustain mod_release))
                  (set! amp (* amplitude adsr1_val))
                  (set! cof (clamp (+ filter_frq (* follow_frq frequency) (* follow_amp amplitude)
                                      (* adsr4_val (aref mods PARAM_FILTER_FRQ))
                                      (* filter_env_amt adsr2_val))
                                   0.0 22000.0))
                  (set! res (+ reso (* adsr4_val (aref mods PARAM_FILTER_RES))))
                  (set! frq (+ frequency (* pitch_env_amt frequency adsr3_val) 0.0))
                  (if (< frq 10.0) (set! frq 10.0))
                  ;; if gate is OFF and amp is sufficiently close to 0.0 then stop note!
                  (if (< (note_gate data) 0.1) (set! reltime (+ reltime 1)))
                  (if (> reltime amp_release_samples)
                      (begin
                        ;; (println "NOTE OFF!" data)
                        (note_active data #f)))
                  ;; (if (and (< gate 0.5) (< amp 0.00001)) (note_active data #f))
                  ;; setup mod sources
                  (if (> osc1_amp 0.001)
                      (set! osc1_out (* (+ osc1_amp (* adsr4_val (aref mods PARAM_OSC1_AMP)))
                                        (cond ((= osc1_wave 0) (sin1 1.0 (+ (* tune1 frq) (* adsr4_val (aref mods PARAM_OSC1_FRQ)))))
                                              ((= osc1_wave 1) (saw1 1.0 (+ (* tune1 frq) (* adsr4_val (aref mods PARAM_OSC1_FRQ)))))
                                              ((= osc1_wave 2) (pulse1 1.0 (+ (* tune1 frq) 
                                                                              (* adsr4_val (aref mods PARAM_OSC1_FRQ)))
                                                                       (+ pw1 (* adsr4_val (aref mods PARAM_OSC1_PW)))))
                                              ((= osc1_wave 3) (tri1 1.0 (+ (* tune1 frq) (* adsr4_val (aref mods PARAM_OSC1_FRQ)))))
                                              (else zero))))
                      (set! osc1_out 0.0))
                  (if (> osc2_amp 0.001)
                      (set! osc2_out (* (+ osc2_amp (* adsr4_val (aref mods PARAM_OSC2_AMP)))
                                        (cond ((= osc2_wave 0) (sin2 1.0 (+ (* tune2 frq) (* adsr4_val (aref mods PARAM_OSC2_FRQ)))))
                                              ((= osc2_wave 1) (saw2 1.0 (+ (* tune2 frq) (* adsr4_val (aref mods PARAM_OSC2_FRQ)))))
                                              ((= osc2_wave 2) (pulse2 1.0 (+ (* tune2 frq) (* adsr4_val (aref mods PARAM_OSC2_FRQ)))
                                                                       (+ pw2 (* adsr4_val (aref mods PARAM_OSC2_PW)))))
                                              ((= osc2_wave 3) (tri2 1.0 (+ (* tune2 frq) (* adsr4_val (aref mods PARAM_OSC2_FRQ)))))
                                              (else zero))))
                      (set! osc2_out 0.0))
                  (if (> osc3_amp 0.001)
                      (set! osc3_out (* (+ osc3_amp (* adsr4_val (aref mods PARAM_OSC3_AMP)))
                                        (cond ((= osc3_wave 0) (sin3 1.0 (+ (* tune3 frq) (* adsr4_val (aref mods PARAM_OSC3_FRQ)))))
                                              ((= osc3_wave 1) (saw3 1.0 (+ (* tune3 frq) (* adsr4_val (aref mods PARAM_OSC3_FRQ)))))
                                              ((= osc3_wave 2) (pulse3 1.0 (+ (* tune3 frq) (* adsr4_val (aref mods PARAM_OSC3_FRQ)))
                                                                       (+ pw3 (* adsr4_val (aref mods PARAM_OSC3_PW)))))
                                              ((= osc3_wave 3) (tri3 1.0 (+ (* tune3 frq) (* adsr4_val (aref mods PARAM_OSC3_FRQ)))))
                                              (else zero))))
                      (set! osc3_out 0.0))
                  (if (> osc4_amp 0.001)
                      (set! osc4_out (* (+ osc4_amp (* adsr4_val (aref mods PARAM_OSC4_AMP)))
                                        (cond ((= osc4_wave 0) (sin4 1.0 (+ (* tune4 frq) (* adsr4_val (aref mods PARAM_OSC4_FRQ)))))
                                              ((= osc4_wave 1) (saw4 1.0 (+ (* tune4 frq) (* adsr4_val (aref mods PARAM_OSC4_FRQ)))))
                                              ((= osc4_wave 2) (pulse4 1.0 (+ (* tune4 frq) (* adsr4_val (aref mods PARAM_OSC4_FRQ)))
                                                                       (+ pw4 (* adsr4_val (aref mods PARAM_OSC4_PW)))))
                                              ((= osc4_wave 3) (tri4 1.0 (+ (* tune4 frq) (* adsr4_val (aref mods PARAM_OSC4_FRQ)))))
                                              (else zero))))
                      (set! osc4_out 0.0))
                  (if (> sub_amp 0.001)
                      (set! sub_out (* sub_amp (subosc 1.0 (* frq 0.25))))
                      (set! sub_out 0.0))
                  (if (> noise_amp 0.001)
                      (if (= noise PARAM_WHITE)
                          (set! noise_out (* 0.5 (+ noise_amp (* adsr4_val (aref mods PARAM_NOISE_AMP))) (white)))
                          (set! noise_out (* 0.5 (+ noise_amp (* adsr4_val (aref mods PARAM_NOISE_AMP))) (pink))))
                      (set! noise_out 0.0))))
            (if (= chan 0)
                (* amp (filter (+ (* osc1_out osc1_pan)
                                  (* osc2_out osc2_pan)
                                  (* osc3_out osc3_pan)
                                  (* osc4_out osc4_pan)
                                  (* sub_out sub_pan)
                                  (* noise_out noise_pan))
                        cof reso))
                (if (= chan 1)
                    (* amp (filterR (+ (* osc1_out (- 1.0 osc1_pan))
                                        (* osc2_out (- 1.0 osc2_pan))
                                        (* osc3_out (- 1.0 osc3_pan))
                                        (* osc4_out (- 1.0 osc4_pan))
                                        (* sub_out (- 1.0 sub_pan))
                                        (* noise_out (- 1.0 noise_pan)))
                              cof reso))
                    0.0:f))))))))


;; FX
(bind-func analogue_fx
  (let ((MILLISEC (* .001 SRf))
        (CHANSF (i32tof CHANNELS)))
    (lambda ()
      (let ((notekernel:NOTE_KERNEL null)            
            (mod_amp:|4,SAMPLE|* (array_ref 1.0 1.0 1.0 1.0))
            (mod_frq:|4,SAMPLE|* (array_ref 1.0 1.0 1.0 1.0))
            (mod_attack:|4,SAMPLE|* (array_ref 10.0 10.0 10.0 10.0)) ;; in millis
            (mod_decay:|4,SAMPLE|* (array_ref 10.0 10.0 10.0 10.0))
            (mod_attack_slope:|4,SAMPLE|* (array_ref 0.0 0.0 0.0 0.0)) ;; between -1.0 log and 1.0 exp  (0.0 is linear)
            (mod_decay_slope:|4,SAMPLE|* (array_ref 0.0 0.0 0.0 0.0))
            (mods:|32,SAMPLE|* null) ;(alloc))
            (mod_matrix:|4,|32,SAMPLE||* (alloc))
            (tmpmod:|32,SAMPLE|* null)
            (lfos:|4,|6,[SAMPLE,i64,i64]*||* (alloc))
            (lfo_types:|4,i32|* (alloc))
            (hpf (hpf_c))
            (hpfR (hpf_c))
            (hpf_frq 20001.0)
            (dly (comb_lpf_mc_c (i32toi64 CHANNELS) (* SR 120))) ;; max 120 sec delay     
            (delay_time_left 50.0) ;; in ms
            (delay_time_right 50.0) ;; in ms
            (delay_in 1.0)
            (delay_mix 0.0)
            (delay_fb 0.5)
            (delay_frq 12000.0)
            (delay_res 0.0)
            (rev (reverb_st_c))
            (reverb_mix 0.0)
            (reverb_predelay 40.0) ;; in ms
            (reverb_size 0.3)
            (reverb_absorb 0.45)
            (pan (pan_c (i32toi64 CHANNELS)))
            (pan_pos 0.5)          
            (pan_width 1.0)
            (flanger (flanger_st_c))
            (flanger_low 0.1)
            (flanger_high 15.0)
            (flanger_rate 1.0)
            (flanger_fb 0.0)
            (flanger_mix 0.0)
            (overdrive (overdrive_c))
            (overdrive_amt 0.5) ;; always use some overdrive
            (out:SAMPLE 0.0)
            (i:i64 0) (j:i64 0)
            (tmp 0.0)
            (fxout 0.0)
            (gain 2.0))
        (dotimes (i 4)
          (aset! lfo_types i PARAM_SINE)
          (aset! lfos i
                 (array (let ((osc (osc_c 0.0)))
                          (lambda (chan:i64 idx:i64)
                            (osc (aref mod_amp idx)
                                 (aref mod_frq idx))))
                        (let ((osc (saw_c 0.0)))
                          (lambda (chan:i64 idx:i64)
                            (osc (aref mod_amp idx)
                                 (aref mod_frq idx))))
                        (let ((osc (pulse_c 0.0)))
                          (lambda (chan:i64 idx:i64)
                            (osc (aref mod_amp idx)
                                 (aref mod_frq idx)
                                 0.5)))
                        (let ((osc (tri_c 0.0)))
                          (lambda (chan:i64 idx:i64)
                            (osc (aref mod_amp idx)
                                 (aref mod_frq idx))))
                        (let ((osc (ad_c)))
                          (cset! osc cycle #t i1)
                          (lambda (chan:i64 idx:i64)
                            (osc chan 1.0
                                 (aref mod_attack idx)
                                 (aref mod_decay idx)
                                 (aref mod_attack_slope idx)
                                 (aref mod_decay_slope idx))))
                        (lambda (chan:i64 idx:i64) (aref mod_amp idx))))) ;; constant
        (lambda (in:SAMPLE time:i64 chan:i64 dat:SAMPLE*)
          ;; calc mod matrix changes
          (begin
            (if (= mods null) (set! mods (notekernel.mods:|32,SAMPLE|*)))
            (memset (cast mods i8*) 0 128) ;(size_of mods))
            (dotimes (i 4)
              (set! tmp ((aref (aref-ptr lfos i) (aref lfo_types i)) chan i))
              (set! tmpmod (aref-ptr mod_matrix i))
              (dotimes (j 32) (aset! mods j (+ (aref mods j) (* tmp (aref tmpmod j)))))
              void))
          ;; sound in for channel 1
          (if (= chan 0)
              (begin
                (set! out in)
                (set! out (overdrive out overdrive_amt))
                (if (< hpf_frq 20000.0)
                    (set! out (hpf out hpf_frq 0.0)))
                out))
          ;; sound in for channel 2
          (if (= chan 1)
              (begin
                (set! out in)
                (set! out (overdrive out overdrive_amt))
                (if (< hpf_frq 20000.0)
                    (set! out (hpfR out hpf_frq 0.0)))
                out))
          ;; apply FX to both channels 1 and 2
          (set! tmp (+ pan_pos (aref mods PARAM_PAN_POS)))
          (if (> tmp CHANSF) (set! tmp (- tmp CHANSF)))
          ;; always with the panning!
          (set! fxout (pan chan out
                           (+ pan_width (aref mods PARAM_PAN_WIDTH))
                           tmp))
          (if (> flanger_mix 0.001)
              (set! fxout (flanger chan fxout
                                   1.0 flanger_mix
                                   (* MILLISEC (+ flanger_low 0.0)) ;(aref mods PARAM_FLANGER_LOW)))
                                   (* MILLISEC (+ flanger_high 0.0)) ;(aref mods PARAM_FLANGER_HIGH)))
                                   (+ flanger_rate 0.0) ;(aref mods PARAM_FLANGER_RATE))
                                   (+ flanger_fb 0.0)))) ;;(aref mods PARAM_FLANGER_FB)))))
          (if (> delay_mix 0.001)
              (set! fxout (dly chan fxout
                               (if (= chan 0)
                                   (* MILLISEC (+ delay_time_left (aref mods PARAM_DELAY_TIME_LEFT)))
                                   (* MILLISEC (+ delay_time_right (aref mods PARAM_DELAY_TIME_RIGHT))))
                               delay_in
                               delay_mix
                               (+ delay_fb (aref mods PARAM_DELAY_FB))
                               delay_frq
                               delay_res)))
          (if (> reverb_mix 0.001)
              (set! fxout (rev chan fxout
                               (+ reverb_size (aref mods PARAM_REVERB_SIZE))
                               (+ reverb_predelay (aref mods PARAM_REVERB_PREDELAY))
                               (+ reverb_absorb (aref mods PARAM_REVERB_ABSORB))
                               (+ reverb_mix (aref mods PARAM_REVERB_MIX)))))
          (* gain fxout))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; NOTE KERNEL PARAM SETTERS
;;
;; Please note that these params apply to *any* instrument
;; instrument builders should try to stick to known names if possible
;;


;;
(bind-func analogue_reset
  (let ((i 0) (j 0))
    (lambda (inst:i8*)
      ;;
      ;; oscillators
      ;;
      ;; amplitude of osc 1
      (set_osc1_amp inst 0.5)
      ;; waveform of osc 1 (PARAM_SINE,PARAM_SAW,PARAM_PULSE,PARAM_TRI)
      (set_osc1_wave inst PARAM_SAW)
      ;; frequency shift of osc - tuning - 2.0 up tune 0.5 down tune etc..
      (set_osc1_tune inst 1.0)
      ;; pulse width (for PARAM_PULSE wave) 0.0-1.0 (0.5 is square)
      (set_osc1_pw inst 0.5)
      ;; stereo pan (default is 0.5)
      (set_osc1_pan inst 0.5)
      ;; amplitude of osc 2
      (set_osc2_amp inst 0.0)
      ;; waveform of osc 2 (PARAM_SINE,PARAM_SAW,PARAM_PULSE,PARAM_TRI)
      (set_osc2_wave inst PARAM_SAW)
      ;; frequency shift of osc - tuning - 2.0 up tune 0.5 down tune etc..
      (set_osc2_tune inst 1.0)
      ;; pulse width (for PARAM_PULSE wave) 0.0-1.0 (0.5 is square)
      (set_osc2_pw inst 0.5)
      ;; stereo pan (default is 0.5)
      (set_osc2_pan inst 0.5)      
      ;; amplitude of osc 3
      (set_osc3_amp inst 0.0)
      ;; waveform of osc 3 (PARAM_SINE,PARAM_SAW,PARAM_PULSE,PARAM_TRI)
      (set_osc3_wave inst PARAM_SAW)
      ;; frequency shift of osc - tuning - 2.0 up tune 0.5 down tune etc..
      (set_osc3_tune inst 1.0)
      ;; pulse width (for PARAM_PULSE wave) 0.0-1.0 (0.5 is square)
      (set_osc3_pw inst 0.5)
      ;; stereo pan (default is 0.5)
      (set_osc3_pan inst 0.5)
      ;; amplitude of osc 4
      (set_osc4_amp inst 0.0)
      ;; waveform of osc 3 (PARAM_SINE,PARAM_SAW,PARAM_PULSE,PARAM_TRI)
      (set_osc4_wave inst PARAM_SAW)
      ;; frequency shift of osc - tuning - 2.0 up tune 0.5 down tune etc..
      (set_osc4_tune inst 1.0)
      ;; pulse width (for PARAM_PULSE wave) 0.0-1.0 (0.5 is square)
      (set_osc4_pw inst 0.5)
      ;; stereo pan (default is 0.5)
      (set_osc4_pan inst 0.5)            
      ;; sub oscilltor amp (two tunes under sine wave)
      (set_sub_amp inst 0.0)
      ;; noise (PARAM_WHITE or PARAM_PINK)
      (set_noise_type inst PARAM_WHITE)
      ;; noise amplitude
      (set_noise_amp inst 0.0)
      ;;
      ;; filters
      ;;
      ;; lpf filter cutoff frq in hz
      (set_filter_frq inst 15000.0)
      ;; lpf filter resonance (0.0-1.0)
      (set_filter_res inst 0.0)
      ;; hpf cutoff frequency
      (set_hpf_frq inst 20001.0)
      ;;
      ;; envelopes
      ;;
      ;; main amplitude adsr envelope (adr in ms) (sus [0.0-1.0])
      (set_amp_env inst 0.0 0.0 1.0 0.0)
      ;; filter (LPF) adsr envelope (adr in ms) (sus [0.0-1.0])
      (set_filter_env inst 0.0 0.0 1.0 0.0)
      ;; the amount of filter envelope to apply in hz 0.0 - 20000.0
      ;; this envelope is summed to the current filter_frq
      (set_filter_env_amt inst 0.0)
      ;; follow note frequency as a percentage of the note frequency
      ;; i.e. (+ cutoff (* frequency value))
      (set_filter_env_follow_frq inst 0.0)
      ;; follow note amplitude as a frequency related to the note amplitude
      ;; i.e. (+ cutoff (* amplitude value))
      (set_filter_env_follow_amp inst 0.0)
      ;; pitch envelope attack and decay only in ms
      (set_pitch_env inst 0.0 0.0)
      ;; the amount of pitch envelope to apply as a ratio of the note frequency
      ;; i.e. a value of 1.0 will add 1 tune to current pitch
      ;;      a value of 0.5 will subtract 1 tune 
      (set_pitch_env_amt inst 0.0)      
      ;;
      ;; delay
      ;;
      ;; delay time in ms
      (set_delay_time_left inst 0.0)
      (set_delay_time_right inst 0.0)
      ;; delay amt (gain) 0.0-1.0
      (set_delay_mix inst 0.0)
      ;; delay fb
      (set_delay_fb inst 0.0)
      ;; delay damping (cutoff frq)
      (set_delay_frq inst 12000.0)
      ;; delay resonance
      (set_delay_res inst 0.0)
      ;;
      ;; reverb 
      ;;
      ;; reverb_mix 0.0-1.0 0.0 is dry 1.0 is wet
      (set_reverb_mix inst 0.0)
      ;; reverb size (room size) 0.0-1.0 - 1.0 is large
      (set_reverb_size inst 0.4)
      ;; reverb predelay in ms (up to 2 seconds)
      (set_reverb_predelay inst 40.0)
      ;; reverb absorbtion 0.0-1.0
      (set_reverb_absorb inst 0.45)
      ;;
      ;; flanger
      ;;
      (set_flanger_mix inst 0.0)
      ;; the low mark (time in ms) for the flanger
      (set_flanger_low inst 0.001)
      ;; the high mark (time in ms) for the flanger
      (set_flanger_high inst 10.0)
      ;; the rate (in hz) of the flanger
      (set_flanger_rate inst 0.01)
      ;; any feedback -1.0 - 1.0
      (set_flanger_fb inst 0.5)
      ;;
      ;; panning
      ;;
      ;; see pan_c in audio_dsp for detailed info
      ;; about the values for pos and width
      ;; for channels > 2
      ;;
      ;; pan pos 0.0-1.0 (assuming stereo)
      (set_pan_pos inst 0.5)
      ;; pan width 1.0
      (set_pan_width inst 1.0)
      ;;
      ;; gain
      ;;
      (set_gain inst 2.0)
      ;;
      ;; portamento (in millis)
      (set_portamento inst 2.0)
      ;;
      ;; set max polyphony
      (set_polyphonic inst)
      ;;
      ;; lfos
      ;;
      ;; attack, decay, attack slope, decay slope
      ;; attack ins ms, decay in ms, attack & decay slopes -1.0 log and 1.0 exp (0.0 is linear)
      (set_lfo_ad inst PARAM_LFO1 10.0 10.0 0.0 0.0)
      (set_lfo_ad inst PARAM_LFO2 10.0 10.0 0.0 0.0)
      (set_lfo_ad inst PARAM_LFO3 10.0 10.0 0.0 0.0)
      (set_lfo_ad inst PARAM_LFO4 10.0 10.0 0.0 0.0)
      ;; set amp frq
      (set_lfo inst PARAM_LFO1 1.0 1.0)
      (set_lfo inst PARAM_LFO2 1.0 1.0)
      (set_lfo inst PARAM_LFO3 1.0 1.0)
      (set_lfo inst PARAM_LFO4 1.0 1.0)
      ;; set LFO type
      (set_lfo_type inst PARAM_LFO1 PARAM_SINE)
      (set_lfo_type inst PARAM_LFO2 PARAM_SINE)
      (set_lfo_type inst PARAM_LFO3 PARAM_SINE)
      (set_lfo_type inst PARAM_LFO4 PARAM_SINE)
      ;;
      ;; mod matrix
      ;;
      ;; reset mod matrix - turn everything off
      (dotimes (i 4)   ;; 4 modulation sources
        (doloop (j 32) ;; 32 modulation targets
          (set_mod_matrix inst i j 0.0)))    
      
      ;; mod env
      (set_mod_env inst 0.0 0.0 1.0 0.0)

      ;; filter saturation (range between 1.0 - 3.0)
      (set_filter_drive inst 1.0)
      
      ;; done
      (println "Analogue Synthesizer Reset!")
      void)))


;;
(bind-func analogue_load_state
  (let ((i 0) (j 0))
    (lambda (inst:i8* data:|512,i32|*)
      ;;
      ;; oscillators
      ;;
      ;; amplitude of osc 1
      (set_osc1_amp inst (unswap32f (aref data 0)))
      ;; waveform of osc 1 (PARAM_SINE,PARAM_SAW,PARAM_PULSE,PARAM_TRI)
      (set_osc1_wave inst (unswap32i (aref data 1)))
      ;; frequency shift of osc - tuning - 2.0 up tune 0.5 down tune etc..
      (set_osc1_tune inst (unswap32f (aref data 2)))
      ;; pulse width (for PARAM_PULSE wave) 0.0-1.0 (0.5 is square)
      (set_osc1_pw inst (unswap32f (aref data 3)))
      ;; stereo pan (default is 0.5)
      (set_osc1_pan inst (unswap32f (aref data 4)))

      ;; amplitude of osc 2
      (set_osc2_amp inst (unswap32f (aref data 5)))
      ;; waveform of osc (PARAM_SINE,PARAM_SAW,PARAM_PULSE,PARAM_TRI)
      (set_osc2_wave inst (unswap32i (aref data 6)))
      ;; frequency shift of osc - tuning - 2.0 up tune 0.5 down tune etc..
      (set_osc2_tune inst (unswap32f (aref data 7)))
      ;; pulse width (for PARAM_PULSE wave) 0.0-1.0 (0.5 is square)
      (set_osc2_pw inst (unswap32f (aref data 8)))
      ;; stereo pan (default is 0.5)
      (set_osc2_pan inst (unswap32f (aref data 9)))

      ;; amplitude of osc 3
      (set_osc3_amp inst (unswap32f (aref data 10)))
      ;; waveform of osc (PARAM_SINE,PARAM_SAW,PARAM_PULSE,PARAM_TRI)
      (set_osc3_wave inst (unswap32i (aref data 11)))
      ;; frequency shift of osc - tuning - 2.0 up tune 0.5 down tune etc..
      (set_osc3_tune inst (unswap32f (aref data 12)))
      ;; pulse width (for PARAM_PULSE wave) 0.0-1.0 (0.5 is square)
      (set_osc3_pw inst (unswap32f (aref data 13)))
      ;; stereo pan (default is 0.5)
      (set_osc3_pan inst (unswap32f (aref data 14)))

      ;; amplitude of osc 4
      (set_osc4_amp inst (unswap32f (aref data 15)))
      ;; waveform of osc (PARAM_SINE,PARAM_SAW,PARAM_PULSE,PARAM_TRI)
      (set_osc4_wave inst (unswap32i (aref data 16)))
      ;; frequency shift of osc - tuning - 2.0 up tune 0.5 down tune etc..
      (set_osc4_tune inst (unswap32f (aref data 17)))
      ;; pulse width (for PARAM_PULSE wave) 0.0-1.0 (0.5 is square)
      (set_osc4_pw inst (unswap32f (aref data 18)))
      ;; stereo pan (default is 0.5)
      (set_osc4_pan inst (unswap32f (aref data 19)))


      ;; sub oscilltor amp (two tunes under sine wave)
      (set_sub_amp inst (unswap32f (aref data 20)))
      ;; noise (PARAM_WHITE or PARAM_PINK)
      (set_noise_type inst (unswap32i (aref data 21)))
      ;; noise amplitude
      (set_noise_amp inst (unswap32f (aref data 22)))
      ;;
      ;; filters
      ;;
      ;; lpf filter cutoff frq in hz
      (set_filter_frq inst (unswap32f (aref data 23)))
      ;; lpf filter resonance (0.0-1.0)
      (set_filter_res inst (unswap32f (aref data 24)))
      ;; hpf cutoff frequency
      (set_hpf_frq inst (unswap32f (aref data 25)))
      ;;
      ;; envelopes
      ;;
      ;; main amplitude adsr envelope (adr in ms) (sus [0.0-1.0])
      (set_amp_env inst
                   (unswap32f (aref data 26))
                   (unswap32f (aref data 27))
                   (unswap32f (aref data 28))
                   (unswap32f (aref data 29)))
      ;; filter (LPF) adsr envelope (adr in ms) (sus [0.0-1.0])
      (set_filter_env inst
                      (unswap32f (aref data 30))
                      (unswap32f (aref data 31))
                      (unswap32f (aref data 32))
                      (unswap32f (aref data 33)))
      ;; the amount of filter envelope to apply in hz 0.0 - 20000.0
      ;; this envelope is summed to the current filter_frq
      (set_filter_env_amt inst (unswap32f (aref data 34)))
      ;; follow note frequency as a percentage of the note frequency
      ;; i.e. (+ cutoff (* frequency value))
      (set_filter_env_follow_frq inst (unswap32f (aref data 35)))
      ;; follow note amplitude as a frequency related to the note amplitude
      ;; i.e. (+ cutoff (* amplitude value))
      (set_filter_env_follow_amp inst (unswap32f (aref data 36)))
      ;; pitch envelope attack and decay only in ms
      (set_pitch_env inst (unswap32f (aref data 37)) (unswap32f (aref data 38)))
      ;; the amount of pitch envelope to apply as a ratio of the note frequency
      ;; i.e. a value of 1.0 will add 1 tune to current pitch
      ;;      a value of 0.5 will subtract 1 tune 
      (set_pitch_env_amt inst (unswap32f (aref data 39)))
      ;;
      ;; delay
      ;;
      ;; delay time in ms
      (set_delay_time_left inst (unswap32f (aref data 40)))
      (set_delay_time_right inst (unswap32f (aref data 41)))
      ;; delay amt (gain) 0.0-1.0
      (set_delay_mix inst (unswap32f (aref data 42)))
      ;; delay fb
      (set_delay_fb inst (unswap32f (aref data 43)))
      ;; delay damping (cutoff frq)
      (set_delay_frq inst (unswap32f (aref data 44)))
      ;; delay resonance
      (set_delay_res inst (unswap32f (aref data 45)))
      ;;
      ;; reverb 
      ;;
      ;; reverb_mix 0.0-1.0 0.0 is dry 1.0 is wet
      (set_reverb_mix inst (unswap32f (aref data 46)))
      ;; reverb size (room size) 0.0-1.0 - 1.0 is large
      (set_reverb_size inst (unswap32f (aref data 47)))
      ;; reverb predelay in ms (up to 2 seconds)
      (set_reverb_predelay inst (unswap32f (aref data 48)))
      ;; reverb absorbtion 0.0-1.0
      (set_reverb_absorb inst (unswap32f (aref data 49)))
      ;;
      ;; flanger
      ;;
      (set_flanger_mix inst (unswap32f (aref data 50)))
      ;; the low mark (time in ms) for the flanger
      (set_flanger_low inst (unswap32f (aref data 51)))
      ;; the high mark (time in ms) for the flanger
      (set_flanger_high inst (unswap32f (aref data 52)))
      ;; the rate (in hz) of the flanger
      (set_flanger_rate inst (unswap32f (aref data 53)))
      ;; any feedback -1.0 - 1.0
      (set_flanger_fb inst (unswap32f (aref data 54)))
      ;;
      ;; panning
      ;;
      ;; see pan_c in audio_dsp for detailed info
      ;; about the values for pos and width
      ;; for channels > 2
      ;;
      ;; pan pos 0.0-1.0 (assuming stereo)
      (set_pan_pos inst (unswap32f (aref data 55)))
      ;; pan width 1.0
      (set_pan_width inst (unswap32f (aref data 56)))
      ;;
      ;; gain
      ;;
      (set_gain inst (unswap32f (aref data 57)))
      ;;
      ;; portamento (in millis)
      (set_portamento inst (unswap32f (aref data 58)))
      ;;
      ;; set max polyphony
      (set_polyphonic inst)
      ;;
      ;; lfos
      ;;
      ;; attack, decay, attack slope, decay slope
      ;; attack ins ms, decay in ms, attack & decay slopes -1.0 log
      ;; and 1.0 exp (0.0 is linear)
      (set_lfo_ad inst PARAM_LFO1
                  (unswap32f (aref data 59))
                  (unswap32f (aref data 60))
                  (unswap32f (aref data 61))
                  (unswap32f (aref data 62)))

      (set_lfo_ad inst PARAM_LFO2
                  (unswap32f (aref data 63))
                  (unswap32f (aref data 64))
                  (unswap32f (aref data 65))
                  (unswap32f (aref data 66)))

      (set_lfo_ad inst PARAM_LFO3
                  (unswap32f (aref data 67))
                  (unswap32f (aref data 68))
                  (unswap32f (aref data 69))
                  (unswap32f (aref data 70)))

      (set_lfo_ad inst PARAM_LFO4
                  (unswap32f (aref data 71))
                  (unswap32f (aref data 72))
                  (unswap32f (aref data 73))
                  (unswap32f (aref data 74)))      

      ;; set amp frq      
      (set_lfo inst PARAM_LFO1
               (unswap32f (aref data 75))
               (unswap32f (aref data 76)))

      (set_lfo inst PARAM_LFO2
               (unswap32f (aref data 77))
               (unswap32f (aref data 78)))

      (set_lfo inst PARAM_LFO3
               (unswap32f (aref data 79))
               (unswap32f (aref data 80)))

      (set_lfo inst PARAM_LFO4
               (unswap32f (aref data 81))
               (unswap32f (aref data 82)))
      
      ;; set LFO type
      (set_lfo_type inst PARAM_LFO1 (unswap32i (aref data 83)))
      (set_lfo_type inst PARAM_LFO2 (unswap32i (aref data 84)))
      (set_lfo_type inst PARAM_LFO3 (unswap32i (aref data 85)))
      (set_lfo_type inst PARAM_LFO4 (unswap32i (aref data 86)))
      ;;
      ;; mod matrix
      ;;
      ;; reset mod matrix - turn everything off
      (dotimes (i 4)   ;; 4 modulation sources
        (doloop (j 32) ;; 32 modulation targets
          (set_mod_matrix inst i j (unswap32f (aref data (+ 87 (* i 32) j))))))
      
      ;; mod_env 
      (set_mod_env inst
              (unswap32f (aref data 220))
              (unswap32f (aref data 221))
              (unswap32f (aref data 222))
              (unswap32f (aref data 223)))
      
      ;; filter saturation
      (set_filter_drive inst (unswap32f (aref data 224)))

      ;; doneat
      (println "Analogue Synthesizer Load preset!")
      void)))


(bind-func analogue_save_state
  (let ((i 0) (j 0)
        (data:|512,i32|* (halloc))
        (idx:i64 0))
    (lambda (inst:i8*)
      ;;
      ;; oscillators
      ;;
      ;; amplitude of osc
      (aset! data 0 (swap32f (get_osc1_amp inst)))
       ;; waveform of osc 1 (PARAM_SINE,PARAM_SAW,PARAM_PULSE,PARAM_TRI)
      (aset! data 1 (swap32i (get_osc1_wave inst)))
      ;; frequency shift of osc - tuning - 2.0 up tune 0.5 down tune etc..
      (aset! data 2 (swap32f (get_osc1_tune inst)))
      ;; pulse width (for PARAM_PULSE wave) 0.0-1.0 (0.5 is square)
      (aset! data 3 (swap32f (get_osc1_pw inst)))
      ;; stereo pan (default is 0.5)
      (aset! data 4 (swap32f (get_osc1_pan inst)))
      
      ;; amplitude of osc 2
      (aset! data 5 (swap32f (get_osc2_amp inst)))
      ;; waveform of osc 2 (PARAM_SINE,PARAM_SAW,PARAM_PULSE,PARAM_TRI)
      (aset! data 6 (swap32i (get_osc2_wave inst)))
      ;; frequency shift of osc - tuning - 2.0 up tune 0.5 down tune etc..
      (aset! data 7 (swap32f (get_osc2_tune inst)))
      ;; pulse width (for PARAM_PULSE wave) 0.0-1.0 (0.5 is square)
      (aset! data 8 (swap32f (get_osc2_pw inst)))
      ;; stereo pan (default is 0.5)
      (aset! data 9 (swap32f (get_osc2_pan inst)))
      
      ;; amplitude of osc 3
      (aset! data 10 (swap32f (get_osc3_amp inst)))
      ;; waveform of osc 3 (PARAM_SINE,PARAM_SAW,PARAM_PULSE,PARAM_TRI)
      (aset! data 11 (swap32i (get_osc3_wave inst)))
      ;; frequency shift of osc - tuning - 2.0 up tune 0.5 down tune etc..
      (aset! data 12 (swap32f (get_osc3_tune inst)))
      ;; pulse width (for PARAM_PULSE wave) 0.0-1.0 (0.5 is square)
      (aset! data 13 (swap32f (get_osc3_pw inst)))
      ;; stereo pan (default is 0.5)
      (aset! data 14 (swap32f (get_osc3_pan inst)))
      
      ;; amplitude of osc 4
      (aset! data 15 (swap32f (get_osc4_amp inst)))
      ;; waveform of osc 3 (PARAM_SINE,PARAM_SAW,PARAM_PULSE,PARAM_TRI)
      (aset! data 16 (swap32i (get_osc4_wave inst)))
      ;; frequency shift of osc - tuning - 2.0 up tune 0.5 down tune etc..
      (aset! data 17 (swap32f (get_osc4_tune inst)))
      ;; pulse width (for PARAM_PULSE wave) 0.0-1.0 (0.5 is square)
      (aset! data 18 (swap32f (get_osc4_pw inst)))
      ;; stereo pan (default is 0.5)
      (aset! data 19 (swap32f (get_osc4_pan inst)))
      
      ;; sub oscilltor amp (two tunes under sine wave)
      (aset! data 20 (swap32f (get_sub_amp inst)))
      ;; noise (PARAM_WHITE or PARAM_PINK)
      (aset! data 21 (swap32i (get_noise_type inst)))
      
      ;; noise amplitude
      (aset! data 22 (swap32f (get_noise_amp inst)))
      ;;
      ;; filters
      ;;
      ;; lpf filter cutoff frq in hz
      (aset! data 23 (swap32f (get_filter_frq inst)))
      ;; lpf filter resonance (0.0-1.0)
      (aset! data 24 (swap32f (get_filter_res inst)))
      ;; hpf cutoff frequency
      (aset! data 25 (swap32f (get_hpf_frq inst)))

      ;;
      ;; envelopes
      ;;
      ;; main amplitude adsr envelope (adr in ms) (sus [0.0-1.0])
      (let ((arr (get_amp_env inst))) ;; 10.0 10.0 0.6 50.0)
        (aset! data 26 (swap32f (aref arr 0))) ;; attack
        (aset! data 27 (swap32f (aref arr 1))) ;; decay
        (aset! data 28 (swap32f (aref arr 2))) ;; sustain
        (aset! data 29 (swap32f (aref arr 3)))) ;; release

      ;; filter (LPF) adsr envelope (adr in ms) (sus [0.0-1.0])
      (let ((arr (get_filter_env inst)))
        (aset! data 30 (swap32f (aref arr 0))) ;; attack
        (aset! data 31 (swap32f (aref arr 1))) ;; decay
        (aset! data 32 (swap32f (aref arr 2))) ;; sustain
        (aset! data 33 (swap32f (aref arr 3)))) ;; release
                
      ;; the amount of filter envelope to apply in hz 0.0 - 20000.0
      ;; this envelope is summed to the current filter_frq
      (aset! data 34 (swap32f (get_filter_env_amt inst)))

      ;; follow note frequency as a percentage of the note frequency
      ;; i.e. (+ cutoff (* frequency value))
      (aset! data 35 (swap32f (get_filter_env_follow_frq inst)))
      ;; follow note amplitude as a frequency related to the note amplitude
      ;; i.e. (+ cutoff (* amplitude value))
      (aset! data 36 (swap32f (get_filter_env_follow_amp inst)))
      ;; pitch envelope attack and decay only in ms
      (let ((arr (get_pitch_env inst)))
        (aset! data 37 (swap32f (aref arr 0))) ;; attack
        (aset! data 38 (swap32f (aref arr 1)))) ;; decay
      ;; the amount of pitch envelope to apply as a ratio of the note frequency
      ;; i.e. a value of 1.0 will add 1 tune to current pitch
      ;;      a value of 0.5 will subtract 1 tune
      (aset! data 39 (swap32f (get_pitch_env_amt inst)))
      ;;
      ;; delay
      ;;
      ;; delay time in ms
      (aset! data 40 (swap32f (get_delay_time_left inst)))
      (aset! data 41 (swap32f (get_delay_time_right inst)))
      ;; delay amt (gain) 0.0-1.0
      (aset! data 42 (swap32f (get_delay_mix inst)))
      ;; delay fb
      (aset! data 43 (swap32f (get_delay_fb inst)))
      ;; delay damping (cutoff frq)
      (aset! data 44 (swap32f (get_delay_frq inst)))
      ;; delay resonance
      (aset! data 45 (swap32f (get_delay_res inst)))
      ;;
      ;; reverb 
      ;;
      ;; reverb_mix 0.0-1.0 0.0 is dry 1.0 is wet
      (aset! data 46 (swap32f (get_reverb_mix inst)))
      ;; reverb size (room size) 0.0-1.0 - 1.0 is large
      (aset! data 47 (swap32f (get_reverb_size inst)))
      ;; reverb predelay in ms (up to 2 seconds)
      (aset! data 48 (swap32f (get_reverb_predelay inst)))
      ;; reverb absorbtion 0.0-1.0
      (aset! data 49 (swap32f (get_reverb_absorb inst)))
      ;;
      ;; flanger
      ;;
      (aset! data 50 (swap32f (get_flanger_mix inst)))
      ;; the low mark (time in ms) for the flanger
      (aset! data 51 (swap32f (get_flanger_low inst)))
      ;; the high mark (time in ms) for the flanger
      (aset! data 52 (swap32f (get_flanger_high inst)))
      ;; the rate (in hz) of the flanger
      (aset! data 53 (swap32f (get_flanger_rate inst)))
      ;; any feedback -1.0 - 1.0
      (aset! data 54 (swap32f (get_flanger_fb inst)))
      ;;
      ;; panning
      ;;
      ;; see pan_c in audio_dsp for detailed info
      ;; about the values for pos and width
      ;; for channels > 2
      ;;
      ;; pan pos 0.0-1.0 (assuming stereo)
      (aset! data 55 (swap32f (get_pan_pos inst)))
      ;; pan width 1.0
      (aset! data 56 (swap32f (get_pan_width inst)))
      ;;
      ;; gain
      ;;
      (aset! data 57 (swap32f (get_gain inst)))
      ;;
      ;; portamento (in millis)
      (aset! data 58 (swap32f (get_portamento inst)))
      ;;
      ;; set max polyphony
      ;; (aset! data 59 (swap32f (get_polyphonic inst)))
      ;;
      ;; lfos
      ;;
      ;; attack, decay, attack slope, decay slope
      ;; attack ins ms, decay in ms, attack & decay slopes -1.0 log
      ;; and 1.0 exp (0.0 is linear)
      (let ((arr:|4,float| (get_lfo_ad inst PARAM_LFO1)))
        (aset! data 59 (swap32f (aref arr 0))) ;; attack
        (aset! data 60 (swap32f (aref arr 1))) ;; decay
        (aset! data 61 (swap32f (aref arr 2))) ;; attack slope
        (aset! data 62 (swap32f (aref arr 3)))) ;; decay slope

      (let ((arr:|4,float| (get_lfo_ad inst PARAM_LFO2)))
        (aset! data 63 (swap32f (aref arr 0))) ;; attack
        (aset! data 64 (swap32f (aref arr 1))) ;; decay
        (aset! data 65 (swap32f (aref arr 2))) ;; attack slope
        (aset! data 66 (swap32f (aref arr 3)))) ;; decay slope        

      (let ((arr:|4,float| (get_lfo_ad inst PARAM_LFO3)))
        (aset! data 67 (swap32f (aref arr 0))) ;; attack
        (aset! data 68 (swap32f (aref arr 1))) ;; decay
        (aset! data 69 (swap32f (aref arr 2))) ;; attack slope
        (aset! data 70 (swap32f (aref arr 3)))) ;; decay slope        

      (let ((arr:|4,float| (get_lfo_ad inst PARAM_LFO4)))
        (aset! data 71 (swap32f (aref arr 0))) ;; attack
        (aset! data 72 (swap32f (aref arr 1))) ;; decay
        (aset! data 73 (swap32f (aref arr 2))) ;; attack slope
        (aset! data 74 (swap32f (aref arr 3)))) ;; decay slope

      ;; set amp frq
      (let ((arr:|2,float| (get_lfo inst PARAM_LFO1)))
        (aset! data 75 (swap32f (aref arr 0))) ;; attack
        (aset! data 76 (swap32f (aref arr 1)))) ;; decay

      (let ((arr:|2,float| (get_lfo inst PARAM_LFO2)))
        (aset! data 77 (swap32f (aref arr 0))) ;; attack
        (aset! data 78 (swap32f (aref arr 1)))) ;; decay

      (let ((arr:|2,float| (get_lfo inst PARAM_LFO3)))
        (aset! data 79 (swap32f (aref arr 0))) ;; attack
        (aset! data 80 (swap32f (aref arr 1)))) ;; decay

      (let ((arr:|2,float| (get_lfo inst PARAM_LFO4)))
        (aset! data 81 (swap32f (aref arr 0))) ;; attack
        (aset! data 82 (swap32f (aref arr 1)))) ;; decay
      
      ;; set LFO type
      (aset! data 83 (swap32i (get_lfo_type inst PARAM_LFO1)))
      (aset! data 84 (swap32i (get_lfo_type inst PARAM_LFO2)))
      (aset! data 85 (swap32i (get_lfo_type inst PARAM_LFO3)))
      (aset! data 86 (swap32i (get_lfo_type inst PARAM_LFO4)))
      ;;
      ;; mod matrix
      ;;
      ;; reset mod matrix - turn everything off
      (dotimes (i 4)   ;; 4 modulation sources
        (doloop (j 32) ;; 32 modulation targets
          (aset! data (+ (* i 32) j 87) (swap32f (get_mod_matrix inst i j)))))  
    
      ;; main amplitude adsr envelope (adr in ms) (sus [0.0-1.0])
      (let ((arr (get_mod_env inst))) ;; 10.0 10.0 0.6 50.0)
        (aset! data 220 (swap32f (aref arr 0))) ;; attack
        (aset! data 221 (swap32f (aref arr 1))) ;; decay
        (aset! data 222 (swap32f (aref arr 2))) ;; sustain
        (aset! data 223 (swap32f (aref arr 3)))) ;; release
  
      ;; filter saturation
      (aset! data 224 (swap32f (get_filter_drive inst)))    
  
      data)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func synth_write_file
  (lambda (fname dat size)
    (let ((fptr (fopen fname "wb")))
        (fwrite dat size 1 fptr)
        (fclose fptr))))

(bind-func synth_load_file
  (lambda (fname size)
    (let ((fptr (fopen fname "rb"))
          (dat:i8* (halloc size)))
        (fread dat size 1 fptr)
        (fclose fptr)
        dat)))

(bind-func save_synth
  (lambda (synth:i8* fname)
    (let ((dat (analogue_save_state (cast synth i8*))))
     (synth_write_file fname (cast dat i8*) 2048)
      void)))

(bind-func load_synth
  (lambda (synth:i8* fname)
    (let ((dat (synth_load_file fname 2048)))
      (analogue_load_state synth (cast dat |512,i32|*))
      void)))


;;;;;;;;;;;;;;;;;;;;;



;; load the scheme macros (e.g. bind-instrument)
(sys:load "libs/core/instruments-scm.xtm")
;; make sure we load them with AOT-compiled code as well
(impc:aot:insert-forms
 (sys:load "libs/core/instruments-scm.xtm"))

(impc:aot:insert-footer "xtminstruments")

(define *xtmlib-instruments-loaded* #t)
